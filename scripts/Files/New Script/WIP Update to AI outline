/**
 * Icon Variant Generator for Adobe Illustrator (v2)
 * 
 * Creates stroke-based icon variants at multiple sizes and weights.
 * Stroke widths are calibrated to match Geologica font weights.
 * 
 * Usage:
 * 1. Open your icon in Illustrator (stroke-based paths)
 * 2. File > Scripts > Other Script... > select this file
 * 3. Configure options in tabs and click Generate
 */

// Check if we're in Illustrator
if (app.name !== "Adobe Illustrator") {
   alert("This script is designed for Adobe Illustrator.");
} else {

// ============================================================================
// CONFIGURATION - Stroke widths calibrated to Geologica font at 32x32
// ============================================================================

var STROKE_WIDTHS = {
  100: 2.22,   // Thin
  200: 2.78,   // ExtraLight
  300: 3.35,   // Light
  400: 3.91,   // Regular
  500: 4.48,   // Medium
  600: 5.05,   // SemiBold
  700: 5.61,   // Bold
  800: 6.18,   // ExtraBold
  900: 6.74    // Black
};

var WEIGHT_NAMES = {
  100: 'Thin',
  200: 'ExtraLight', 
  300: 'Light',
  400: 'Regular',
  500: 'Medium',
  600: 'SemiBold',
  700: 'Bold',
  800: 'ExtraBold',
  900: 'Black'
};

var PRESET_SIZES = {
  'Common': [16, 24, 32, 48],
  'All Standard': [16, 18, 20, 24, 32, 48, 64, 128],
  'Small': [12, 14, 16, 18, 20],
  'Medium': [24, 32, 40, 48],
  'Large': [48, 64, 96, 128, 256]
};

// Common sizes to show as individual checkboxes
var AVAILABLE_SIZES = [12, 14, 16, 18, 20, 24, 32, 40, 48, 64, 96, 128, 256];

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

function calculateStroke(weight, size) {
  var baseStroke = STROKE_WIDTHS[weight] || STROKE_WIDTHS[400];
  return (baseStroke / 32) * size;
}

function applyStrokeWidth(item, strokeWidth) {
  try {
      if (item.typename === 'PathItem') {
          if (item.stroked) item.strokeWidth = strokeWidth;
      } else if (item.typename === 'CompoundPathItem') {
          for (var i = 0; i < item.pathItems.length; i++) {
              if (item.pathItems[i].stroked) item.pathItems[i].strokeWidth = strokeWidth;
          }
      } else if (item.typename === 'GroupItem') {
          for (var j = 0; j < item.pageItems.length; j++) {
              applyStrokeWidth(item.pageItems[j], strokeWidth);
          }
      }
  } catch (e) {
      // Item may be locked or unmodifiable, skip it
  }
}

function getOriginalStrokeWidth(item) {
  try {
      if (item.typename === 'PathItem') {
          if (item.stroked && item.strokeWidth > 0) {
              return item.strokeWidth;
          }
      } else if (item.typename === 'CompoundPathItem') {
          for (var i = 0; i < item.pathItems.length; i++) {
              if (item.pathItems[i].stroked && item.pathItems[i].strokeWidth > 0) {
                  return item.pathItems[i].strokeWidth;
              }
          }
      } else if (item.typename === 'GroupItem') {
          for (var j = 0; j < item.pageItems.length; j++) {
              var stroke = getOriginalStrokeWidth(item.pageItems[j]);
              if (stroke > 0) return stroke;
          }
      }
  } catch (e) {
      // Item may be locked or unmodifiable, skip it
  }
  return null;
}

function getOriginalInnerStrokeWidth(item) {
  try {
      var outerSize = getLargestElementSize(item);
      if (outerSize <= 0) return null;
      
      function findInnerStroke(element, isTopLevel) {
          try {
              if (element.typename === 'GroupItem') {
                  if (isTopLevel) {
                      for (var i = 0; i < element.pageItems.length; i++) {
                          var stroke = findInnerStroke(element.pageItems[i], false);
                          if (stroke > 0) return stroke;
                      }
                  } else {
                      var bounds = element.geometricBounds;
                      if (bounds && bounds.length === 4) {
                          var width = bounds[2] - bounds[0];
                          var height = bounds[1] - bounds[3];
                          var elementSize = Math.max(width, height);
                          
                          if (elementSize < outerSize * 0.98) {
                              var stroke = findInnerStroke(element, false);
                              if (stroke > 0) return stroke;
                          }
                          
                          for (var j = 0; j < element.pageItems.length; j++) {
                              var stroke = findInnerStroke(element.pageItems[j], false);
                              if (stroke > 0) return stroke;
                          }
                      }
                  }
              } else if (element.typename === 'PathItem') {
                  var pathBounds = element.geometricBounds;
                  if (pathBounds && pathBounds.length === 4) {
                      var pathWidth = pathBounds[2] - pathBounds[0];
                      var pathHeight = pathBounds[1] - pathBounds[3];
                      var pathSize = Math.max(pathWidth, pathHeight);
                      
                      if (!isTopLevel && pathSize < outerSize * 0.98 && element.stroked && element.strokeWidth > 0) {
                          return element.strokeWidth;
                      }
                  }
              } else if (element.typename === 'CompoundPathItem') {
                  var pathBounds = element.geometricBounds;
                  if (pathBounds && pathBounds.length === 4) {
                      var pathWidth = pathBounds[2] - pathBounds[0];
                      var pathHeight = pathBounds[1] - pathBounds[3];
                      var pathSize = Math.max(pathWidth, pathHeight);
                      
                      if (!isTopLevel && pathSize < outerSize * 0.98) {
                          for (var k = 0; k < element.pathItems.length; k++) {
                              if (element.pathItems[k].stroked && element.pathItems[k].strokeWidth > 0) {
                                  return element.pathItems[k].strokeWidth;
                              }
                          }
                      }
                  }
              }
          } catch (e) {
              // Skip items that can't be processed
          }
          return null;
      }
      
      return findInnerStroke(item, true);
  } catch (e) {
      return null;
  }
}

function getLargestElementSize(item) {
  var maxSize = 0;
  try {
      if (item.typename === 'GroupItem') {
          for (var j = 0; j < item.pageItems.length; j++) {
              var childSize = getLargestElementSize(item.pageItems[j]);
              if (childSize > maxSize) maxSize = childSize;
          }
      } else if (item.typename === 'PathItem' || item.typename === 'CompoundPathItem') {
          var bounds = item.geometricBounds;
          if (bounds && bounds.length === 4) {
              var width = bounds[2] - bounds[0];
              var height = bounds[1] - bounds[3];
              maxSize = Math.max(width, height);
          }
      }
  } catch (e) {
      // Item may be locked or unmodifiable, skip it
  }
  return maxSize;
}

function scaleInnerElements(item, scaleFactor, isTopLevel, outerSize) {
  try {
      if (item.typename === 'GroupItem') {
          if (isTopLevel) {
              for (var j = 0; j < item.pageItems.length; j++) {
                  scaleInnerElements(item.pageItems[j], scaleFactor, false, outerSize);
              }
          } else {
              var bounds = item.geometricBounds;
              if (bounds && bounds.length === 4) {
                  var width = bounds[2] - bounds[0];
                  var height = bounds[1] - bounds[3];
                  var elementSize = Math.max(width, height);
                  
                  if (outerSize > 0 && elementSize < outerSize * 0.95) {
                      item.resize(
                          scaleFactor * 100, scaleFactor * 100,
                          true, true, true, true,
                          scaleFactor * 100,
                          Transformation.CENTER
                      );
                  }
                  
                  for (var k = 0; k < item.pageItems.length; k++) {
                      scaleInnerElements(item.pageItems[k], scaleFactor, false, outerSize);
                  }
              }
          }
      } else if (item.typename === 'PathItem' || item.typename === 'CompoundPathItem') {
          if (!isTopLevel) {
              var pathBounds = item.geometricBounds;
              if (pathBounds && pathBounds.length === 4) {
                  var pathWidth = pathBounds[2] - pathBounds[0];
                  var pathHeight = pathBounds[1] - pathBounds[3];
                  var pathSize = Math.max(pathWidth, pathHeight);
                  
                  if (outerSize > 0 && pathSize < outerSize * 0.95) {
                      item.resize(
                          scaleFactor * 100, scaleFactor * 100,
                          true, true, true, true,
                          scaleFactor * 100,
                          Transformation.CENTER
                      );
                  }
              }
          }
      }
  } catch (e) {
      // Item may be locked or unmodifiable, skip it
  }
}

function applyInnerShapeStyling(item, options, outerStrokeWidth, currentWeight, currentSize) {
  try {
      // Get the largest element size to identify outer shape
      var outerSize = getLargestElementSize(item);
      
      // Recursively apply styling to inner shapes
      function applyToInnerShapes(element, isTopLevel, parentIsInner) {
          try {
              if (element.typename === 'GroupItem') {
                  if (isTopLevel) {
                      // Process all children at top level
                      for (var i = 0; i < element.pageItems.length; i++) {
                          applyToInnerShapes(element.pageItems[i], false, false);
                      }
                  } else {
                      // Check if this is an inner shape
                      var bounds = element.geometricBounds;
                      var isInnerShape = false;
                      if (bounds && bounds.length === 4) {
                          var width = bounds[2] - bounds[0];
                          var height = bounds[1] - bounds[3];
                          var elementSize = Math.max(width, height);
                          
                          // If smaller than outer (use 0.98 threshold to be less strict), it's an inner shape
                          if (outerSize > 0 && elementSize < outerSize * 0.98) {
                              isInnerShape = true;
                              applyStylingToItem(element, currentWeight, currentSize);
                          }
                      }
                      
                      // Recursively process children (if parent is inner, children are also inner)
                      for (var j = 0; j < element.pageItems.length; j++) {
                          applyToInnerShapes(element.pageItems[j], false, isInnerShape || parentIsInner);
                      }
                  }
              } else if (element.typename === 'PathItem' || element.typename === 'CompoundPathItem') {
                  if (!isTopLevel) {
                      var pathBounds = element.geometricBounds;
                      var shouldApply = false;
                      
                      if (parentIsInner) {
                          // If parent is identified as inner, apply to this item too
                          shouldApply = true;
                      } else if (pathBounds && pathBounds.length === 4) {
                          var pathWidth = pathBounds[2] - pathBounds[0];
                          var pathHeight = pathBounds[1] - pathBounds[3];
                          var pathSize = Math.max(pathWidth, pathHeight);
                          
                          // If smaller than outer (use 0.98 threshold), it's an inner shape
                          if (outerSize > 0 && pathSize < outerSize * 0.98) {
                              shouldApply = true;
                          }
                      }
                      
                      if (shouldApply) {
                          applyStylingToItem(element, currentWeight, currentSize);
                      }
                  }
              }
          } catch (e) {
              // Skip items that can't be processed
          }
      }
      
      // Apply styling to a specific item
      function applyStylingToItem(itemElement, weight, size) {
          try {
              // Apply fill if enabled
              if (options.innerShapeFill) {
                  if (itemElement.typename === 'PathItem') {
                      itemElement.filled = true;
                      // Use current stroke color for fill, or default black
                      if (itemElement.stroked && itemElement.strokeColor) {
                          itemElement.fillColor = itemElement.strokeColor;
                      }
                  } else if (itemElement.typename === 'CompoundPathItem') {
                      for (var p = 0; p < itemElement.pathItems.length; p++) {
                          itemElement.pathItems[p].filled = true;
                          if (itemElement.pathItems[p].stroked && itemElement.pathItems[p].strokeColor) {
                              itemElement.pathItems[p].fillColor = itemElement.pathItems[p].strokeColor;
                          }
                      }
                  }
              }
              
              // Calculate inner stroke width (only if calculation mode is set)
              var innerStrokeWidth;
              if (options.innerCalcMode !== undefined) {
                  var calculatedStroke;
                  
                  if (options.innerCalcMode === 0) { // Auto
                      var divisor = options.innerAutoDivisor || 2;
                      // Use the stroke width value from STROKE_WIDTHS for this weight, divided by divisor
                      var baseStrokeWidth = STROKE_WIDTHS[weight] || STROKE_WIDTHS[400];
                      calculatedStroke = baseStrokeWidth / divisor;
                  } else if (options.innerCalcMode === 1) { // Percent
                      var baseStroke = options.innerBaseStroke || 100;
                      var weightMultiplier = (weight - 100) / 100;
                      var increasePerWeight = options.innerIncreasePerWeight || 0;
                      calculatedStroke = baseStroke + (baseStroke * (increasePerWeight / 100) * weightMultiplier);
                  } else { // Amount
                      var baseStroke = options.innerBaseStroke || 100;
                      var weightMultiplier = (weight - 100) / 100;
                      var increasePerWeight = options.innerIncreasePerWeight || 0;
                      calculatedStroke = baseStroke + (increasePerWeight * weightMultiplier);
                  }
                  
                  // Scale to current size (same scaling as outer stroke)
                  innerStrokeWidth = (calculatedStroke / 32) * size;
              }
              
              // Apply stroke width and alignment
              if (itemElement.typename === 'PathItem') {
                  // Apply stroke alignment (always apply if specified, even if item is already stroked)
                  if (options.innerStrokeAlign !== undefined) {
                      // Ensure item is stroked before setting alignment
                      if (!itemElement.stroked) {
                          itemElement.stroked = true;
                      }
                      
                      try {
                          // Try using constants first
                          if (options.innerStrokeAlign === 0) {
                              itemElement.strokeAlignment = StrokeAlignment.OUTSIDEALIGNMENT;
                          } else if (options.innerStrokeAlign === 1) {
                              itemElement.strokeAlignment = StrokeAlignment.CENTERALIGNMENT;
                          } else if (options.innerStrokeAlign === 2) {
                              itemElement.strokeAlignment = StrokeAlignment.INSIDEALIGNMENT;
                          }
                      } catch (e1) {
                          // If constants don't work, try numeric values
                          try {
                              itemElement.strokeAlignment = options.innerStrokeAlign;
                          } catch (e2) {
                              // Stroke alignment may not be available in all versions
                          }
                      }
                  }
                  
                  // Apply stroke width if calculation mode is set
                  if (options.innerCalcMode !== undefined && innerStrokeWidth !== undefined) {
                      if (!itemElement.stroked) {
                          itemElement.stroked = true;
                      }
                      itemElement.strokeWidth = innerStrokeWidth;
                  }
              } else if (itemElement.typename === 'CompoundPathItem') {
                  for (var cp = 0; cp < itemElement.pathItems.length; cp++) {
                      // Apply stroke alignment (always apply if specified, even if item is already stroked)
                      if (options.innerStrokeAlign !== undefined) {
                          // Ensure path item is stroked before setting alignment
                          if (!itemElement.pathItems[cp].stroked) {
                              itemElement.pathItems[cp].stroked = true;
                          }
                          
                          try {
                              // Try using constants first
                              if (options.innerStrokeAlign === 0) {
                                  itemElement.pathItems[cp].strokeAlignment = StrokeAlignment.OUTSIDEALIGNMENT;
                              } else if (options.innerStrokeAlign === 1) {
                                  itemElement.pathItems[cp].strokeAlignment = StrokeAlignment.CENTERALIGNMENT;
                              } else if (options.innerStrokeAlign === 2) {
                                  itemElement.pathItems[cp].strokeAlignment = StrokeAlignment.INSIDEALIGNMENT;
                              }
                          } catch (e1) {
                              // If constants don't work, try numeric values
                              try {
                                  itemElement.pathItems[cp].strokeAlignment = options.innerStrokeAlign;
                              } catch (e2) {
                                  // Stroke alignment may not be available in all versions
                              }
                          }
                      }
                      
                      // Apply stroke width if calculation mode is set
                      if (options.innerCalcMode !== undefined && innerStrokeWidth !== undefined) {
                          if (!itemElement.pathItems[cp].stroked) {
                              itemElement.pathItems[cp].stroked = true;
                          }
                          itemElement.pathItems[cp].strokeWidth = innerStrokeWidth;
                      }
                  }
              }
          } catch (e) {
              // Skip items that can't be styled
          }
      }
      
      // Start processing from top level
      applyToInnerShapes(item, true, false);
  } catch (e) {
      // Skip if styling can't be applied
  }
}

function detectPathsInsideInnerShapes(item) {
  var detectedPaths = [];
  var innerShapeGroups = [];
  try {
      var pathIndex = 0;
      var groupIndex = 0;
      var useNamingStructure = false;
      
      // Helper function to check if a name matches "inner" (case-insensitive)
      function isInnerName(name) {
          if (!name) return false;
          var lowerName = name.toLowerCase().trim();
          return lowerName === "inner" || lowerName.indexOf("inner") === 0;
      }
      
      // Helper function to check if a name matches "inner 1", "inner 2", etc. (case-insensitive)
      function isInnerGroupName(name) {
          if (!name) return false;
          var lowerName = name.toLowerCase().trim();
          // Match "inner 1", "inner1", "inner 2", "inner2", etc.
          return /^inner\s*\d+/.test(lowerName) || lowerName.indexOf("inner") === 0;
      }
      
      // First pass: Try to find "inner" layer/group using naming structure
      function findInnerContainer(element) {
          try {
              // Check if this is a layer or group named "inner"
              if (element.typename === 'Layer' || element.typename === 'GroupItem') {
                  if (isInnerName(element.name)) {
                      return element;
                  }
                  
                  // Check pageItems for layers or groups
                  if (element.pageItems) {
                      for (var i = 0; i < element.pageItems.length; i++) {
                          var found = findInnerContainer(element.pageItems[i]);
                          if (found) return found;
                      }
                  }
                  
                  // Check layers if this is a document
                  if (element.typename === 'Document' && element.layers) {
                      for (var j = 0; j < element.layers.length; j++) {
                          if (isInnerName(element.layers[j].name)) {
                              return element.layers[j];
                          }
                      }
                  }
              }
          } catch (e) {
              // Skip
          }
          return null;
      }
      
      // Try to find inner container using naming
      var innerContainer = findInnerContainer(item);
      
      // Function to find inner groups (can be called on container or top-level item)
      function findInnerGroups(container) {
          try {
              // Handle both GroupItem and Layer
              // Note: When Layers are moved to a GroupItem, they become GroupItems but may still have .layers property
              var items = [];
              if (container.typename === 'Layer') {
                  items = container.pageItems || [];
              } else if (container.typename === 'GroupItem') {
                  items = container.pageItems || [];
              } else {
                  items = container.pageItems || container.pathItems || [];
              }
              
              // For GroupItems, also check if they have a .layers property (converted Layers)
              if (container.typename === 'GroupItem') {
                  try {
                      if (container.layers && container.layers.length > 0) {
                          for (var nl = 0; nl < container.layers.length; nl++) {
                              items.push(container.layers[nl]);
                          }
                      }
                  } catch (e) {
                      // Skip if can't access layers
                  }
              }
              
              for (var i = 0; i < items.length; i++) {
                  var element = items[i];
                  // Check by name pattern, not just typename (since Layers become GroupItems when moved)
                  var elementName = element.name || "";
                  if ((element.typename === 'GroupItem' || element.typename === 'Layer') && 
                      (isInnerGroupName(elementName) || isInnerName(elementName))) {
                      var bounds = element.geometricBounds;
                      if (bounds && bounds.length === 4) {
                          var width = bounds[2] - bounds[0];
                          var height = bounds[1] - bounds[3];
                          var elementSize = Math.max(width, height);
                          
                          innerShapeGroups.push({
                              group: element,
                              name: element.name || ("Inner Group " + (groupIndex++)),
                              size: elementSize,
                              bounds: bounds
                          });
                      }
                  }
                  
                  // Recursively search nested groups and layers
                  // Also check for .layers property on GroupItems (converted Layers)
                  if (element.typename === 'GroupItem' || element.typename === 'Layer') {
                      findInnerGroups(element);
                  }
              }
          } catch (e) {
              // Skip
          }
      }
      
      if (innerContainer) {
          useNamingStructure = true;
          // Find all groups named "inner 1", "inner 2", etc. within the inner container
          findInnerGroups(innerContainer);
      } else {
          // Also check for groups named "Inner" directly as children of the top-level item
          // This handles cases where "Inner" is a direct child group (not inside an "inner" container)
          try {
              // Handle both GroupItem and Layer structures
              var topLevelItems = [];
              if (item.typename === 'Layer') {
                  // Layers can have both pageItems and nested layers
                  topLevelItems = item.pageItems || [];
                  // Also add nested layers to the list
                  try {
                      if (item.layers && item.layers.length > 0) {
                          for (var nl = 0; nl < item.layers.length; nl++) {
                              topLevelItems.push(item.layers[nl]);
                          }
                      }
                  } catch (e) {
                      // Skip if can't access layers
                  }
              } else if (item.typename === 'GroupItem') {
                  // GroupItems have pageItems
                  // Note: When Layers are moved to a GroupItem, they become GroupItems
                  // So we need to check pageItems and also check by name pattern
                  topLevelItems = item.pageItems || [];
                  // Also try to access .layers property (might still exist on converted Layers)
                  try {
                      if (item.layers && item.layers.length > 0) {
                          for (var nl2 = 0; nl2 < item.layers.length; nl2++) {
                              topLevelItems.push(item.layers[nl2]);
                          }
                      }
                  } catch (e) {
                      // Skip if can't access layers
                  }
              } else {
                  // Fallback
                  topLevelItems = item.pageItems || item.pathItems || [];
              }
              
              // Function to check an element and its children recursively
              function checkForInnerGroup(element) {
                  var foundAny = false;
                  try {
                      // Check if this element itself is an "Inner" group or layer
                      // Handle names like "Inner", "Inner Layer", "Inner Grouped", etc.
                      var elementName = element.name || "";
                      var isInnerElement = (element.typename === 'GroupItem' || element.typename === 'Layer') && 
                                          (isInnerName(elementName) || isInnerGroupName(elementName));
                      
                      if (isInnerElement) {
                          useNamingStructure = true;
                          var topBounds = element.geometricBounds;
                          if (topBounds && topBounds.length === 4) {
                              var topWidth = topBounds[2] - topBounds[0];
                              var topHeight = topBounds[1] - topBounds[3];
                              var topSize = Math.max(topWidth, topHeight);
                              
                              innerShapeGroups.push({
                                  group: element,
                                  name: element.name || ("Inner Group " + (groupIndex++)),
                                  size: topSize,
                                  bounds: topBounds
                              });
                              foundAny = true;
                          }
                          // Also search for nested inner groups within this "Inner" group/layer
                          findInnerGroups(element);
                      }
                      
                      // Recursively check children if this is a group or layer
                      // Note: Layers become GroupItems when moved, so check pageItems first
                      // Also check by name pattern since structure might have changed
                      if (element.typename === 'GroupItem' || element.typename === 'Layer') {
                          var children = [];
                          try {
                              // Get pageItems (paths, groups, etc.)
                              // When Layers are converted to GroupItems, their nested layers become GroupItems in pageItems
                              children = element.pageItems || [];
                          } catch (e) {
                              // Skip if can't access pageItems
                          }
                          
                          // Check for nested layers - works for both Layers and GroupItems (converted Layers)
                          // But note: converted Layers might not have .layers property anymore
                          try {
                              if (element.layers && element.layers.length > 0) {
                                  // Add nested layers to children list
                                  for (var l = 0; l < element.layers.length; l++) {
                                      children.push(element.layers[l]);
                                  }
                              }
                          } catch (e2) {
                              // Skip if can't access layers
                          }
                          
                          // Also check if any children match "Inner" by name (in case structure changed)
                          for (var c = 0; c < children.length; c++) {
                              var childName = children[c].name || "";
                              // Check by name pattern first (more reliable when structure changes)
                              if ((isInnerName(childName) || isInnerGroupName(childName)) && 
                                  (children[c].typename === 'GroupItem' || children[c].typename === 'Layer')) {
                                  // Found an "Inner" group/layer by name
                                  if (checkForInnerGroup(children[c])) {
                                      foundAny = true;
                                  }
                              } else {
                                  // Recursively check all children
                                  if (checkForInnerGroup(children[c])) {
                                      foundAny = true;
                                  }
                              }
                          }
                      }
                  } catch (e) {
                      // Skip if check fails
                  }
                  return foundAny;
              }
              
              // Check all top-level items and their children recursively
              for (var j = 0; j < topLevelItems.length; j++) {
                  checkForInnerGroup(topLevelItems[j]);
              }
          } catch (e) {
              // Skip if check fails
          }
      }
      
      // Fallback: Use size-based detection if naming structure not found
      if (!useNamingStructure || innerShapeGroups.length === 0) {
          var outerSize = getLargestElementSize(item);
          if (outerSize > 0) {
              // Size-based detection (original method)
              function identifyInnerShapesBySize(element, isTopLevel) {
                  try {
                      if (element.typename === 'GroupItem') {
                          var bounds = element.geometricBounds;
                          if (bounds && bounds.length === 4) {
                              var width = bounds[2] - bounds[0];
                              var height = bounds[1] - bounds[3];
                              var elementSize = Math.max(width, height);
                              
                              // Check if this is an inner shape (smaller than outer)
                              if (!isTopLevel && outerSize > 0 && elementSize < outerSize * 0.98) {
                                  innerShapeGroups.push({
                                      group: element,
                                      name: element.name || ("Inner Group " + (groupIndex++)),
                                      size: elementSize,
                                      bounds: bounds
                                  });
                              }
                          }
                          
                          // Recursively process all children
                          for (var i = 0; i < element.pageItems.length; i++) {
                              identifyInnerShapesBySize(element.pageItems[i], false);
                          }
                      }
                  } catch (e) {
                      // Skip items that can't be processed
                  }
              }
              
              identifyInnerShapesBySize(item, true);
          }
      }
      
      // Second pass: Find all paths within identified inner shape groups
      function findPathsInInnerShapes(element, currentInnerGroup, pathName) {
          try {
              if (element.typename === 'GroupItem' || element.typename === 'Layer') {
                  // Check if this group/layer is an inner shape
                  var matchingInnerGroup = null;
                  for (var g = 0; g < innerShapeGroups.length; g++) {
                      if (element === innerShapeGroups[g].group) {
                          matchingInnerGroup = innerShapeGroups[g];
                          break;
                      }
                  }
                  
                  // Also check by name if not found by reference (handles converted Layers)
                  if (!matchingInnerGroup) {
                      var elementName = element.name || "";
                      if (isInnerName(elementName) || isInnerGroupName(elementName)) {
                          for (var g2 = 0; g2 < innerShapeGroups.length; g2++) {
                              if (innerShapeGroups[g2].name === elementName) {
                                  matchingInnerGroup = innerShapeGroups[g2];
                                  break;
                              }
                          }
                      }
                  }
                  
                  var effectiveInnerGroup = matchingInnerGroup || currentInnerGroup;
                  var groupName = matchingInnerGroup ? matchingInnerGroup.name : (element.name || "Group");
                  
                  // Get children - handle both GroupItem and Layer
                  // Note: Layers become GroupItems when moved, so check pageItems first
                  var children = [];
                  try {
                      // Get pageItems (paths, groups, etc. directly in this element)
                      // When Layers are converted to GroupItems, nested layers become GroupItems in pageItems
                      children = element.pageItems || [];
                  } catch (e) {
                      // Skip if can't access pageItems
                  }
                  
                  // Check for nested layers - works for both Layers and GroupItems (converted Layers)
                  // But note: converted Layers might not have .layers property anymore
                  try {
                      if (element.layers && element.layers.length > 0) {
                          // Add nested layers themselves (they might contain paths)
                          for (var l = 0; l < element.layers.length; l++) {
                              children.push(element.layers[l]);
                          }
                      }
                  } catch (e2) {
                      // Skip if can't access layers
                  }
                  
                  // Recursively process all children (including nested groups and paths)
                  for (var j = 0; j < children.length; j++) {
                      var childName = pathName ? (pathName + " > " + (children[j].name || "Item " + j)) : (groupName + " > " + (children[j].name || "Item " + j));
                      findPathsInInnerShapes(children[j], effectiveInnerGroup, childName);
                  }
              } else if (element.typename === 'PathItem' || element.typename === 'CompoundPathItem') {
                  // Only process paths that are inside an inner shape group
                  if (currentInnerGroup) {
                      var pathBounds = element.geometricBounds;
                      if (pathBounds && pathBounds.length === 4) {
                          var pathWidth = pathBounds[2] - pathBounds[0];
                          var pathHeight = pathBounds[1] - pathBounds[3];
                          var pathSize = Math.max(pathWidth, pathHeight);
                          
                          // Store path info for configuration
                          var displayName = pathName || (element.name || ("Path " + pathIndex++));
                          // Try to get stroke alignment from the path element
                          var pathStrokeAlignment = null;
                          try {
                              if (element.stroked && element.strokeAlignment !== undefined) {
                                  pathStrokeAlignment = element.strokeAlignment;
                              } else if (element.typename === 'CompoundPathItem' && element.pathItems.length > 0) {
                                  if (element.pathItems[0].stroked && element.pathItems[0].strokeAlignment !== undefined) {
                                      pathStrokeAlignment = element.pathItems[0].strokeAlignment;
                                  }
                              }
                          } catch (e) {
                              // Skip if can't access stroke alignment
                          }
                          
                          detectedPaths.push({
                              name: displayName,
                              element: element,
                              width: pathWidth,
                              height: pathHeight,
                              size: pathSize,
                              baseHeight: pathHeight, // Store base height at weight 100
                              innerShapeSize: currentInnerGroup.size,
                              innerShapeGroup: currentInnerGroup,
                              bounds: pathBounds,
                              selected: false,
                              reduceFromTop: false,
                              reduceFromBottom: false,
                              reductionAmountTop: 0.8, // Default: 0.8px per weight increase from top
                              reductionAmountBottom: 0.8, // Default: 0.8px per weight increase from bottom
                              strokeAlignment: pathStrokeAlignment // Store stroke alignment (0=outside, 1=center, 2=inside, null=unknown)
                          });
                      }
                  }
              }
          } catch (e) {
              // Skip items that can't be processed
          }
      }
      
      // Find paths in all identified inner shape groups
      // Also search the entire item structure in case groups weren't found (e.g., converted Layers)
      if (innerShapeGroups.length > 0) {
          for (var g = 0; g < innerShapeGroups.length; g++) {
              findPathsInInnerShapes(innerShapeGroups[g].group, innerShapeGroups[g], "");
          }
      } else {
          // Fallback: if no inner groups found, search entire structure by name pattern
          // This handles cases where Layers were converted and references don't match
          function searchByPattern(element, currentInnerGroup, pathName) {
              try {
                  var elementName = element.name || "";
                  // Check if this element matches "Inner" pattern
                  if ((element.typename === 'GroupItem' || element.typename === 'Layer') &&
                      (isInnerName(elementName) || isInnerGroupName(elementName))) {
                      // Found an "Inner" group/layer - treat as inner group and search for paths
                      var bounds = element.geometricBounds;
                      if (bounds && bounds.length === 4) {
                          var width = bounds[2] - bounds[0];
                          var height = bounds[1] - bounds[3];
                          var size = Math.max(width, height);
                          currentInnerGroup = {
                              group: element,
                              name: elementName,
                              size: size,
                              bounds: bounds
                          };
                      }
                  }
                  
                  // If we have an inner group context, look for paths
                  if (currentInnerGroup && (element.typename === 'PathItem' || element.typename === 'CompoundPathItem')) {
                      var pathBounds = element.geometricBounds;
                      if (pathBounds && pathBounds.length === 4) {
                          var pathWidth = pathBounds[2] - pathBounds[0];
                          var pathHeight = pathBounds[1] - pathBounds[3];
                          var pathSize = Math.max(pathWidth, pathHeight);
                          
                          var displayName = pathName || (element.name || ("Path " + pathIndex++));
                          // Try to get stroke alignment from the path element
                          var pathStrokeAlignment = null;
                          try {
                              if (element.stroked && element.strokeAlignment !== undefined) {
                                  pathStrokeAlignment = element.strokeAlignment;
                              } else if (element.typename === 'CompoundPathItem' && element.pathItems.length > 0) {
                                  if (element.pathItems[0].stroked && element.pathItems[0].strokeAlignment !== undefined) {
                                      pathStrokeAlignment = element.pathItems[0].strokeAlignment;
                                  }
                              }
                          } catch (e) {
                              // Skip if can't access stroke alignment
                          }
                          
                          detectedPaths.push({
                              name: displayName,
                              element: element,
                              width: pathWidth,
                              height: pathHeight,
                              size: pathSize,
                              baseHeight: pathHeight,
                              innerShapeSize: currentInnerGroup.size,
                              innerShapeGroup: currentInnerGroup,
                              bounds: pathBounds,
                              selected: false,
                              reduceFromTop: false,
                              reduceFromBottom: false,
                              reductionAmountTop: 0.8,
                              reductionAmountBottom: 0.8,
                              strokeAlignment: pathStrokeAlignment // Store stroke alignment (0=outside, 1=center, 2=inside, null=unknown)
                          });
                      }
                  }
                  
                  // Recursively search children
                  if (element.typename === 'GroupItem' || element.typename === 'Layer') {
                      var children = [];
                      try {
                          children = element.pageItems || [];
                      } catch (e) {
                          // Skip
                      }
                      try {
                          if (element.layers && element.layers.length > 0) {
                              for (var l = 0; l < element.layers.length; l++) {
                                  children.push(element.layers[l]);
                              }
                          }
                      } catch (e2) {
                          // Skip
                      }
                      for (var c = 0; c < children.length; c++) {
                          var childName = pathName ? (pathName + " > " + (children[c].name || "Item " + c)) : ((element.name || "Group") + " > " + (children[c].name || "Item " + c));
                          searchByPattern(children[c], currentInnerGroup, childName);
                      }
                  }
              } catch (e) {
                  // Skip
              }
          }
          searchByPattern(item, null, "");
      }
      
  } catch (e) {
      // Skip if detection fails
  }
  
  return detectedPaths;
}

function showPathConfigurationDialog(detectedPaths) {
  // Create dialog window
  var dialog = new Window("dialog", "Configure Inner Path Reduction");
  dialog.orientation = "column";
  dialog.alignChildren = ["fill", "top"];
  dialog.spacing = 10;
  dialog.margins = 12;
  dialog.preferredSize = [500, 400];
  
  // Info text
  var infoText = dialog.add("statictext", undefined, "Select paths to reduce and configure height reduction:", {multiline: true});
  infoText.preferredSize = [-1, 30];
  
  // Scrollable panel for path list
  var scrollPanel = dialog.add("panel", undefined, "Detected Paths");
  scrollPanel.orientation = "column";
  scrollPanel.alignChildren = ["fill", "top"];
  scrollPanel.spacing = 6;
  scrollPanel.margins = 10;
  scrollPanel.preferredSize = [-1, 250];
  
  var pathConfigRows = [];
  
  // Create a row for each detected path
  for (var i = 0; i < detectedPaths.length; i++) {
      var path = detectedPaths[i];
      
      // Main row with checkbox and path name
      var pathRow = scrollPanel.add("group");
      pathRow.orientation = "column";
      pathRow.alignChildren = ["fill", "top"];
      pathRow.spacing = 4;
      
      var topRow = pathRow.add("group");
      topRow.orientation = "row";
      topRow.spacing = 8;
      topRow.alignChildren = ["left", "center"];
      
      var pathCb = topRow.add("checkbox", undefined, path.name + " (" + Math.round(path.width) + "x" + Math.round(path.height) + ")");
      pathCb.pathIndex = i;
      pathCb.value = path.selected;
      pathCb.preferredSize = [300, 22];
      
      // Options row (only visible when checked)
      var optionsRow = pathRow.add("group");
      optionsRow.orientation = "row";
      optionsRow.spacing = 8;
      optionsRow.alignChildren = ["left", "center"];
      optionsRow.visible = path.selected;
      
      var spacer = optionsRow.add("statictext", undefined, "");
      spacer.preferredSize = [20, 22];
      
      var reduceFromTopCb = optionsRow.add("checkbox", undefined, "Reduce from top");
      reduceFromTopCb.pathIndex = i;
      reduceFromTopCb.value = path.reduceFromTop;
      
      // Top reduction input (shown when reduceFromTop is checked)
      var topReductionRow = pathRow.add("group");
      topReductionRow.orientation = "row";
      topReductionRow.spacing = 8;
      topReductionRow.alignChildren = ["left", "center"];
      topReductionRow.visible = path.reduceFromTop;
      
      var topSpacer = topReductionRow.add("statictext", undefined, "");
      topSpacer.preferredSize = [40, 22];
      topReductionRow.add("statictext", undefined, "Top reduction per weight:");
      var topReductionInput = topReductionRow.add("edittext", undefined, String(path.reductionAmountTop || 0.8));
      topReductionInput.characters = 6;
      topReductionInput.preferredSize = [50, 22];
      topReductionInput.pathIndex = i;
      topReductionRow.add("statictext", undefined, "px");
      
      var reduceFromBottomCb = optionsRow.add("checkbox", undefined, "Reduce from bottom");
      reduceFromBottomCb.pathIndex = i;
      reduceFromBottomCb.value = path.reduceFromBottom;
      
      // Bottom reduction input (shown when reduceFromBottom is checked)
      var bottomReductionRow = pathRow.add("group");
      bottomReductionRow.orientation = "row";
      bottomReductionRow.spacing = 8;
      bottomReductionRow.alignChildren = ["left", "center"];
      bottomReductionRow.visible = path.reduceFromBottom;
      
      var bottomSpacer = bottomReductionRow.add("statictext", undefined, "");
      bottomSpacer.preferredSize = [40, 22];
      bottomReductionRow.add("statictext", undefined, "Bottom reduction per weight:");
      var bottomReductionInput = bottomReductionRow.add("edittext", undefined, String(path.reductionAmountBottom || 0.8));
      bottomReductionInput.characters = 6;
      bottomReductionInput.preferredSize = [50, 22];
      bottomReductionInput.pathIndex = i;
      bottomReductionRow.add("statictext", undefined, "px");
      
      // Base height display
      var baseHeightRow = pathRow.add("group");
      baseHeightRow.orientation = "row";
      baseHeightRow.spacing = 8;
      baseHeightRow.alignChildren = ["left", "center"];
      var baseSpacer = baseHeightRow.add("statictext", undefined, "");
      baseSpacer.preferredSize = [40, 22];
      baseHeightRow.add("statictext", undefined, "(Base height: " + Math.round(path.baseHeight || path.height) + "px)");
      
      // Stroke alignment radio buttons (shown when path is selected)
      var strokeAlignRow = pathRow.add("group");
      strokeAlignRow.orientation = "row";
      strokeAlignRow.spacing = 8;
      strokeAlignRow.alignChildren = ["left", "center"];
      strokeAlignRow.visible = path.selected;
      
      var alignSpacer = strokeAlignRow.add("statictext", undefined, "");
      alignSpacer.preferredSize = [40, 22];
      strokeAlignRow.add("statictext", undefined, "Stroke alignment:");
      
      // Initialize alignment from path or default to center (1)
      var initialAlignment = path.strokeAlignment !== null && path.strokeAlignment !== undefined ? path.strokeAlignment : 1;
      if (initialAlignment < 0 || initialAlignment > 2) initialAlignment = 1; // Default to center
      
      var alignOutsideRb = strokeAlignRow.add("radiobutton", undefined, "Outside");
      alignOutsideRb.pathIndex = i;
      alignOutsideRb.value = (initialAlignment === 0);
      
      var alignCenterRb = strokeAlignRow.add("radiobutton", undefined, "Center");
      alignCenterRb.pathIndex = i;
      alignCenterRb.value = (initialAlignment === 1);
      
      var alignInsideRb = strokeAlignRow.add("radiobutton", undefined, "Inside");
      alignInsideRb.pathIndex = i;
      alignInsideRb.value = (initialAlignment === 2);
      
      // Set initial alignment in detectedPaths
      detectedPaths[i].strokeAlignment = initialAlignment;
      
      // Radio button group behavior - only one can be selected
      // Use closure to capture the correct radio button references for this path
      (function(idx, outsideRb, centerRb, insideRb) {
          outsideRb.onClick = function() {
              if (this.value) {
                  detectedPaths[idx].strokeAlignment = 0;
                  centerRb.value = false;
                  insideRb.value = false;
              }
          };
          
          centerRb.onClick = function() {
              if (this.value) {
                  detectedPaths[idx].strokeAlignment = 1;
                  outsideRb.value = false;
                  insideRb.value = false;
              }
          };
          
          insideRb.onClick = function() {
              if (this.value) {
                  detectedPaths[idx].strokeAlignment = 2;
                  outsideRb.value = false;
                  centerRb.value = false;
              }
          };
      })(i, alignOutsideRb, alignCenterRb, alignInsideRb);
      
      // Store references
      pathConfigRows.push({
          checkbox: pathCb,
          optionsRow: optionsRow,
          reduceFromTopCb: reduceFromTopCb,
          reduceFromBottomCb: reduceFromBottomCb,
          topReductionRow: topReductionRow,
          topReductionInput: topReductionInput,
          bottomReductionRow: bottomReductionRow,
          bottomReductionInput: bottomReductionInput,
          strokeAlignRow: strokeAlignRow,
          alignOutsideRb: alignOutsideRb,
          alignCenterRb: alignCenterRb,
          alignInsideRb: alignInsideRb
      });
      
      // Handler to show/hide options when checkbox is toggled
      pathCb.onClick = function() {
          var idx = this.pathIndex;
          pathConfigRows[idx].optionsRow.visible = this.value;
          pathConfigRows[idx].strokeAlignRow.visible = this.value;
          pathConfigRows[idx].topReductionRow.visible = this.value && detectedPaths[idx].reduceFromTop;
          pathConfigRows[idx].bottomReductionRow.visible = this.value && detectedPaths[idx].reduceFromBottom;
          detectedPaths[idx].selected = this.value;
      };
      
      // Handlers to update path config
      reduceFromTopCb.onClick = function() {
          var idx = this.pathIndex;
          detectedPaths[idx].reduceFromTop = this.value;
          pathConfigRows[idx].topReductionRow.visible = detectedPaths[idx].selected && this.value;
      };
      
      reduceFromBottomCb.onClick = function() {
          var idx = this.pathIndex;
          detectedPaths[idx].reduceFromBottom = this.value;
          pathConfigRows[idx].bottomReductionRow.visible = detectedPaths[idx].selected && this.value;
      };
      
      topReductionInput.onChange = function() {
          var val = parseFloat(this.text) || 0.8;
          detectedPaths[this.pathIndex].reductionAmountTop = val;
      };
      
      bottomReductionInput.onChange = function() {
          var val = parseFloat(this.text) || 0.8;
          detectedPaths[this.pathIndex].reductionAmountBottom = val;
      };
  }
  
  // Buttons
  var buttonRow = dialog.add("group");
  buttonRow.orientation = "row";
  buttonRow.spacing = 8;
  buttonRow.alignment = ["right", "center"];
  
  var okBtn = buttonRow.add("button", undefined, "OK");
  okBtn.preferredSize = [80, 24];
  
  var cancelBtn = buttonRow.add("button", undefined, "Cancel");
  cancelBtn.preferredSize = [80, 24];
  
  okBtn.onClick = function() {
      // Update global config with selected paths
      innerPathsConfig = [];
      for (var k = 0; k < detectedPaths.length; k++) {
          if (detectedPaths[k].selected) {
              innerPathsConfig.push({
                  name: detectedPaths[k].name,
                  reduceFromTop: detectedPaths[k].reduceFromTop,
                  reduceFromBottom: detectedPaths[k].reduceFromBottom,
                  reductionAmountTop: detectedPaths[k].reductionAmountTop || 0.8,
                  reductionAmountBottom: detectedPaths[k].reductionAmountBottom || 0.8,
                  baseHeight: detectedPaths[k].baseHeight || detectedPaths[k].height,
                  strokeAlignment: detectedPaths[k].strokeAlignment !== null && detectedPaths[k].strokeAlignment !== undefined ? detectedPaths[k].strokeAlignment : 1, // Default to center if not set
                  // Store identifying info (size, position) to match paths during generation
                  width: detectedPaths[k].width,
                  height: detectedPaths[k].height,
                  size: detectedPaths[k].size,
                  innerShapeSize: detectedPaths[k].innerShapeSize
              });
          }
      }
      dialog.close(1);
  };
  
  cancelBtn.onClick = function() {
      dialog.close(0);
  };
  
  dialog.center();
  var result = dialog.show();
}

function reducePathsInsideInnerShapes(item, options, currentWeight, currentSize) {
  try {
      if (!options.reduceInnerPaths || !options.innerPathsConfig || options.innerPathsConfig.length === 0) return;
      
      var pathConfigs = options.innerPathsConfig;
      
      // Get the largest element size to identify outer shape
      var outerSize = getLargestElementSize(item);
      if (outerSize <= 0) return;
      
      // Calculate weight multiplier (how many weight levels above 100)
      var weightMultiplier = Math.max(0, (currentWeight - 100) / 100);
      
      // Calculate stroke thickness increase for inner paths
      // Need to account for inner stroke width (if calculated) and stroke alignment
      var strokeThicknessIncrease = 0;
      
      // Check if inner stroke calculation is enabled
      if (options.innerCalcMode !== undefined) {
          // Inner stroke is being calculated separately - use inner stroke width
          var originalInnerStrokeBase;
          var currentInnerStrokeBase;
          
          if (options.innerCalcMode === 0) { // Auto
              var divisor = options.innerAutoDivisor || 2;
              originalInnerStrokeBase = (STROKE_WIDTHS[100] || 2.22) / divisor;
              currentInnerStrokeBase = (STROKE_WIDTHS[currentWeight] || STROKE_WIDTHS[400]) / divisor;
          } else if (options.innerCalcMode === 1) { // Percent
              var baseStroke = options.innerBaseStroke || 100;
              var originalWeightMultiplier = (100 - 100) / 100; // Always 0 for weight 100
              var currentWeightMultiplier = (currentWeight - 100) / 100;
              var increasePerWeight = options.innerIncreasePerWeight || 0;
              originalInnerStrokeBase = baseStroke + (baseStroke * (increasePerWeight / 100) * originalWeightMultiplier);
              currentInnerStrokeBase = baseStroke + (baseStroke * (increasePerWeight / 100) * currentWeightMultiplier);
          } else { // Amount
              var baseStroke = options.innerBaseStroke || 100;
              var originalWeightMultiplier = (100 - 100) / 100; // Always 0 for weight 100
              var currentWeightMultiplier = (currentWeight - 100) / 100;
              var increasePerWeight = options.innerIncreasePerWeight || 0;
              originalInnerStrokeBase = baseStroke + (increasePerWeight * originalWeightMultiplier);
              currentInnerStrokeBase = baseStroke + (increasePerWeight * currentWeightMultiplier);
          }
          
          // Scale to current size
          var originalInnerStrokeScaled = (originalInnerStrokeBase / 32) * currentSize;
          var currentInnerStrokeScaled = (currentInnerStrokeBase / 32) * currentSize;
          
          // Stroke thickness increase (in pixels at current size)
          strokeThicknessIncrease = Math.max(0, currentInnerStrokeScaled - originalInnerStrokeScaled);
          
          // Check if inner stroke alignment is outside
          // When stroke is outside, it extends beyond path bounds by the full stroke width
          // For outside stroke alignment, the stroke extends outside the path, so the visual size
          // is path bounds + stroke width. However, since we're reducing the path geometry itself,
          // we still use the stroke width increase as calculated above.
          // The outside alignment affects visual appearance but not the path reduction calculation.
      } else {
          // No inner stroke calculation - use outer stroke as fallback
          var originalStrokeBase = STROKE_WIDTHS[100] || 2.22;
          var originalStrokeScaled = (originalStrokeBase / 32) * currentSize;
          var currentStrokeBase = STROKE_WIDTHS[currentWeight] || STROKE_WIDTHS[400];
          var currentStrokeScaled = (currentStrokeBase / 32) * currentSize;
          strokeThicknessIncrease = Math.max(0, currentStrokeScaled - originalStrokeScaled);
      }
      
      // Step 1: Identify inner shape groups using naming structure (preferred) or size-based detection
      var innerShapeGroupsToScale = [];
      
      // Helper functions for naming-based detection
      function isInnerName(name) {
          if (!name) return false;
          var lowerName = name.toLowerCase().trim();
          return lowerName === "inner" || lowerName.indexOf("inner") === 0;
      }
      
      function isInnerGroupName(name) {
          if (!name) return false;
          var lowerName = name.toLowerCase().trim();
          return /^inner\s*\d+/.test(lowerName) || lowerName.indexOf("inner") === 0;
      }
      
      // Try to find inner container using naming structure
      function findInnerContainer(element) {
          try {
              if (element.typename === 'Layer' || element.typename === 'GroupItem') {
                  if (isInnerName(element.name)) {
                      return element;
                  }
                  if (element.pageItems) {
                      for (var i = 0; i < element.pageItems.length; i++) {
                          var found = findInnerContainer(element.pageItems[i]);
                          if (found) return found;
                      }
                  }
              }
          } catch (e) {
              // Skip
          }
          return null;
      }
      
      var innerContainer = findInnerContainer(item);
      var useNamingStructure = false;
      
      if (innerContainer) {
          useNamingStructure = true;
          
          // Check if the inner container contains any configured paths
          var hasConfiguredPaths = false;
          function checkForConfiguredPaths(containerElement) {
              try {
                  if (containerElement.typename === 'PathItem' || containerElement.typename === 'CompoundPathItem') {
                      var pathBounds = containerElement.geometricBounds;
                      if (pathBounds && pathBounds.length === 4) {
                          var pathWidth = pathBounds[2] - pathBounds[0];
                          var pathHeight = pathBounds[1] - pathBounds[3];
                          var pathSize = Math.max(pathWidth, pathHeight);
                          
                          // Get container size for relative comparison
                          var containerBounds = innerContainer.geometricBounds;
                          var containerSize = containerBounds ? Math.max(containerBounds[2] - containerBounds[0], containerBounds[1] - containerBounds[3]) : pathSize;
                          
                          // Check if this path matches any configured path
                          for (var k = 0; k < pathConfigs.length; k++) {
                              var config = pathConfigs[k];
                              var configRelativeSize = (config.size / config.innerShapeSize) * 100;
                              var currentRelativeSize = (pathSize / containerSize) * 100;
                              
                              if (Math.abs(currentRelativeSize - configRelativeSize) < 5) {
                                  hasConfiguredPaths = true;
                                  return true;
                              }
                          }
                      }
                  } else if (containerElement.typename === 'GroupItem' || containerElement.typename === 'Layer') {
                      var items = containerElement.pageItems || containerElement.pathItems || [];
                      for (var j = 0; j < items.length; j++) {
                          if (checkForConfiguredPaths(items[j])) {
                              return true;
                          }
                      }
                  }
              } catch (e) {
                  // Skip
              }
              return false;
          }
          
          // Check if inner container has configured paths
          if (checkForConfiguredPaths(innerContainer)) {
              var containerBounds = innerContainer.geometricBounds;
              if (containerBounds && containerBounds.length === 4) {
                  var containerWidth = containerBounds[2] - containerBounds[0];
                  var containerHeight = containerBounds[1] - containerBounds[3];
                  var containerSize = Math.max(containerWidth, containerHeight);
                  
                  // Scale the entire "inner" container, not individual inner groups
                  innerShapeGroupsToScale.push({
                      group: innerContainer,
                      originalSize: containerSize
                  });
              }
          }
      }
      
      // Fallback to size-based detection if naming structure not found
      if (!useNamingStructure || innerShapeGroupsToScale.length === 0) {
          function identifyInnerShapeGroupsBySize(element, isTopLevel) {
              try {
                  if (element.typename === 'GroupItem') {
                      var bounds = element.geometricBounds;
                      if (bounds && bounds.length === 4) {
                          var width = bounds[2] - bounds[0];
                          var height = bounds[1] - bounds[3];
                          var elementSize = Math.max(width, height);
                          
                          // Check if this is an inner shape (smaller than outer)
                          if (!isTopLevel && outerSize > 0 && elementSize < outerSize * 0.98) {
                              // Check if this group contains any configured paths
                              var hasConfiguredPaths = false;
                              function checkForConfiguredPaths(groupElement) {
                                  try {
                                      if (groupElement.typename === 'PathItem' || groupElement.typename === 'CompoundPathItem') {
                                          var pathBounds = groupElement.geometricBounds;
                                          if (pathBounds && pathBounds.length === 4) {
                                              var pathWidth = pathBounds[2] - pathBounds[0];
                                              var pathHeight = pathBounds[1] - pathBounds[3];
                                              var pathSize = Math.max(pathWidth, pathHeight);
                                              
                                              // Check if this path matches any configured path
                                              for (var k = 0; k < pathConfigs.length; k++) {
                                                  var config = pathConfigs[k];
                                                  var configRelativeSize = (config.size / config.innerShapeSize) * 100;
                                                  var currentRelativeSize = (pathSize / elementSize) * 100;
                                                  
                                                  if (Math.abs(currentRelativeSize - configRelativeSize) < 5) {
                                                      hasConfiguredPaths = true;
                                                      return true;
                                                  }
                                              }
                                          }
                                      } else if (groupElement.typename === 'GroupItem') {
                                          for (var i = 0; i < groupElement.pageItems.length; i++) {
                                              if (checkForConfiguredPaths(groupElement.pageItems[i])) {
                                                  return true;
                                              }
                                          }
                                      }
                                  } catch (e) {
                                      // Skip
                                  }
                                  return false;
                              }
                              
                              if (checkForConfiguredPaths(element)) {
                                  innerShapeGroupsToScale.push({
                                      group: element,
                                      originalSize: elementSize
                                  });
                              }
                          }
                      }
                      
                      // Recursively process all children
                      for (var j = 0; j < element.pageItems.length; j++) {
                          identifyInnerShapeGroupsBySize(element.pageItems[j], false);
                      }
                  }
              } catch (e) {
                  // Skip items that can't be processed
              }
          }
          
          identifyInnerShapeGroupsBySize(item, true);
      }
      
      // Step 2: Scale down the inner container (if using naming structure) or inner shape groups
      // Use a general scale factor based on weight (similar to inner stroke scaling)
      var groupScaleFactor = 1 - (0.1 * weightMultiplier); // 10% reduction per weight level
      groupScaleFactor = Math.max(0.7, Math.min(1.0, groupScaleFactor)); // Clamp between 70% and 100%
      
      // Store original inner container size BEFORE scaling (for matching paths)
      var originalInnerContainerSize = null;
      if (innerContainer && useNamingStructure) {
          var containerBounds = innerContainer.geometricBounds;
          if (containerBounds && containerBounds.length === 4) {
              var containerWidth = containerBounds[2] - containerBounds[0];
              var containerHeight = containerBounds[1] - containerBounds[3];
              originalInnerContainerSize = Math.max(containerWidth, containerHeight);
          }
      }
      
      for (var g = 0; g < innerShapeGroupsToScale.length; g++) {
          try {
              var innerGroup = innerShapeGroupsToScale[g].group;
              // Scale down the inner shape group
              innerGroup.resize(groupScaleFactor * 100, groupScaleFactor * 100, true, true, true, true, groupScaleFactor * 100, Transformation.CENTER);
          } catch (e) {
              // Skip if scaling fails
          }
      }
      
      // Step 3: Apply individual path reductions within scaled inner shape groups
      // Get current inner container size AFTER scaling (for accurate matching)
      var innerContainerSize = null;
      if (innerContainer && useNamingStructure) {
          var containerBounds = innerContainer.geometricBounds;
          if (containerBounds && containerBounds.length === 4) {
              var containerWidth = containerBounds[2] - containerBounds[0];
              var containerHeight = containerBounds[1] - containerBounds[3];
              innerContainerSize = Math.max(containerWidth, containerHeight);
          }
      }
      
      // If we don't have a scaled size, use original (for fallback size-based detection)
      if (!innerContainerSize && originalInnerContainerSize) {
          innerContainerSize = originalInnerContainerSize;
      }
      
      function findAndReducePaths(element, isTopLevel, parentIsInner, innerShapeSize) {
          try {
              if (element.typename === 'GroupItem' || element.typename === 'Layer') {
                  // If using naming structure and this is the inner container, process its children
                  if (useNamingStructure && element === innerContainer) {
                      var items = element.pageItems || element.pathItems || [];
                      // Iterate backwards to avoid issues when items are modified during iteration
                      for (var i = items.length - 1; i >= 0; i--) {
                          // Process inner 1, inner 2, etc. groups and their paths
                          findAndReducePaths(items[i], false, true, innerContainerSize);
                      }
                  } else if (isTopLevel) {
                      // Process all children at top level
                      // Iterate backwards to avoid issues when items are modified during iteration
                      for (var i = element.pageItems.length - 1; i >= 0; i--) {
                          findAndReducePaths(element.pageItems[i], false, false, null);
                      }
                  } else {
                      // Check if this is an inner group (inner 1, inner 2, etc.) when using naming structure
                      var isInnerGroup = false;
                      if (useNamingStructure && innerContainerSize) {
                          if (isInnerGroupName(element.name)) {
                              isInnerGroup = true;
                          }
                      }
                      
                      var bounds = element.geometricBounds;
                      var isInnerShape = false;
                      var currentInnerSize = null;
                      
                      if (bounds && bounds.length === 4) {
                          var width = bounds[2] - bounds[0];
                          var height = bounds[1] - bounds[3];
                          var elementSize = Math.max(width, height);
                          
                          // Check if this is an inner shape (for fallback size-based detection)
                          if (!useNamingStructure && outerSize > 0 && elementSize < outerSize * 0.98) {
                              isInnerShape = true;
                              currentInnerSize = elementSize;
                          }
                      }
                      
                      // Use inner container size if using naming structure, otherwise use calculated size
                      var effectiveInnerSize = (useNamingStructure && isInnerGroup && innerContainerSize) ? innerContainerSize : (currentInnerSize || innerShapeSize);
                      
                      // Recursively process children
                      // Iterate backwards to avoid issues when items are modified during iteration
                      for (var j = element.pageItems.length - 1; j >= 0; j--) {
                          findAndReducePaths(element.pageItems[j], false, isInnerGroup || isInnerShape || parentIsInner, effectiveInnerSize);
                      }
                  }
              } else if (element.typename === 'PathItem' || element.typename === 'CompoundPathItem') {
                  // Process paths that are inside inner groups
                  if (!isTopLevel && (parentIsInner || innerShapeSize !== null)) {
                      var pathBounds = element.geometricBounds;
                      if (pathBounds && pathBounds.length === 4 && innerShapeSize !== null && innerShapeSize > 0) {
                          var pathWidth = pathBounds[2] - pathBounds[0];
                          var pathHeight = pathBounds[1] - pathBounds[3];
                          var pathSize = Math.max(pathWidth, pathHeight);
                          
                          // Try to match this path with configured paths
                          // Prioritize name matching, then fall back to size matching
                          for (var k = 0; k < pathConfigs.length; k++) {
                              var config = pathConfigs[k];
                              
                              // First, try matching by name (most reliable)
                              var nameMatch = false;
                              if (config.name && element.name) {
                                  // Check if path name contains config name or vice versa
                                  var elementName = element.name.toLowerCase();
                                  var configName = config.name.toLowerCase();
                                  // Extract just the path name part (after "inner X > ")
                                  var pathNamePart = elementName.split(">").pop().trim();
                                  var configNamePart = configName.split(">").pop().trim();
                                  // More lenient name matching - check if names are similar
                                  nameMatch = pathNamePart === configNamePart || 
                                             elementName.indexOf(configNamePart) >= 0 || 
                                             configNamePart.indexOf(pathNamePart) >= 0 ||
                                             pathNamePart.indexOf(configNamePart.replace(/\s+/g, "")) >= 0 ||
                                             configNamePart.replace(/\s+/g, "").indexOf(pathNamePart) >= 0;
                              }
                              
                              // If name doesn't match, try size matching
                              var sizeMatch = false;
                              if (!nameMatch) {
                                  // Calculate relative sizes (as percentage of inner shape) to account for scaling
                                  // Note: After inner container scaling, paths are scaled proportionally, so relative sizes remain the same
                                  var currentRelativeSize = (pathSize / innerShapeSize) * 100;
                                  var currentRelativeWidth = (pathWidth / innerShapeSize) * 100;
                                  var currentRelativeHeight = (pathHeight / innerShapeSize) * 100;
                                  
                                  var configRelativeSize = (config.size / config.innerShapeSize) * 100;
                                  var configRelativeWidth = (config.width / config.innerShapeSize) * 100;
                                  var configRelativeHeight = (config.height / config.innerShapeSize) * 100;
                                  
                                  // Match by relative size (more lenient tolerance for better matching)
                                  var sizeTolerance = 12; // Increased from 8
                                  var widthTolerance = 12; // Increased from 8
                                  var heightTolerance = 12; // Increased from 8
                                  sizeMatch = (Math.abs(currentRelativeSize - configRelativeSize) < sizeTolerance &&
                                              Math.abs(currentRelativeWidth - configRelativeWidth) < widthTolerance &&
                                              Math.abs(currentRelativeHeight - configRelativeHeight) < heightTolerance);
                              }
                              
                              // Fallback: Try absolute size matching (accounting for scaling)
                              var absoluteSizeMatch = false;
                              if (!sizeMatch && !nameMatch && originalInnerContainerSize && innerContainerSize) {
                                  var scaleRatio = innerContainerSize / originalInnerContainerSize;
                                  var scaledConfigSize = config.size * scaleRatio;
                                  var scaledConfigWidth = config.width * scaleRatio;
                                  var scaledConfigHeight = config.height * scaleRatio;
                                  
                                  var sizeDiff = Math.abs(pathSize - scaledConfigSize);
                                  var widthDiff = Math.abs(pathWidth - scaledConfigWidth);
                                  var heightDiff = Math.abs(pathHeight - scaledConfigHeight);
                                  
                                  // Match if within 5% of scaled config size
                                  if (sizeDiff < (scaledConfigSize * 0.05) &&
                                      widthDiff < (scaledConfigWidth * 0.05) &&
                                      heightDiff < (scaledConfigHeight * 0.05)) {
                                      absoluteSizeMatch = true;
                                  }
                              }
                              
                              if (sizeMatch || nameMatch || absoluteSizeMatch) {
                                  
                                  // Calculate reduction based on weight and configured pixel amounts
                                  // reductionAmountTop/Bottom are in pixels per weight level increase
                                  // weightMultiplier = (currentWeight - 100) / 100
                                  
                                  var baseHeight = config.baseHeight || pathHeight;
                                  
                                  // Calculate reductions for top and bottom separately
                                  // Reduction = configured amount per weight level + stroke thickness increase
                                  // IMPORTANT: Reduction happens AFTER scaling and stroke changes, so we work in current coordinate space
                                  
                                  // Account for scaling: baseHeight is at weight 100 (before scaling), currentHeight is after all scaling
                                  // Scale factor accounts for: group scaling, inner container scaling, etc.
                                  var scaleFactor = currentHeight / baseHeight;
                                  
                                  // Base reduction amount per weight level (in original coordinate space at weight 100)
                                  // Example: 0.8px per weight level, so at weight 200 (1 level up) = 0.8px
                                  var baseReductionTop = (config.reductionAmountTop || 0.8) * weightMultiplier;
                                  var baseReductionBottom = (config.reductionAmountBottom || 0.8) * weightMultiplier;
                                  
                                  // Scale base reductions to current coordinate space (after all scaling)
                                  var scaledBaseReductionTop = baseReductionTop * scaleFactor;
                                  var scaledBaseReductionBottom = baseReductionBottom * scaleFactor;
                                  
                                  // Skip if no reduction needed (only at weight 100)
                                  // We'll calculate final reduction after getting actual stroke width
                                  if (weightMultiplier < 0.01) {
                                      break;
                                  }
                                  
                                  try {
                                      // Ensure element is unlocked
                                      if (element.locked) {
                                          element.locked = false;
                                      }
                                      var currentBounds = element.geometricBounds;
                                      if (currentBounds && currentBounds.length === 4) {
                                          var currentTop = currentBounds[1];
                                          var currentBottom = currentBounds[3];
                                          var currentLeft = currentBounds[0];
                                          var currentRight = currentBounds[2];
                                          var currentCenterX = (currentLeft + currentRight) / 2;
                                          var currentCenterY = (currentTop + currentBottom) / 2;
                                          var currentHeight = currentTop - currentBottom;
                                          var currentWidth = currentRight - currentLeft;
                                          
                                          // Get actual stroke width from the path (if it has a stroke)
                                          // Stroke alignment comes from the config (set via radio buttons in dialog)
                                          var pathStrokeWidth = 0;
                                          
                                          try {
                                              if (element.stroked && element.strokeWidth > 0) {
                                                  pathStrokeWidth = element.strokeWidth;
                                              } else if (element.typename === 'CompoundPathItem' && element.pathItems.length > 0) {
                                                  // Check first path item for stroke width
                                                  if (element.pathItems[0].stroked && element.pathItems[0].strokeWidth > 0) {
                                                      pathStrokeWidth = element.pathItems[0].strokeWidth;
                                                  }
                                              }
                                          } catch (e) {
                                              // Skip if can't access stroke width
                                          }
                                          
                                          // Get stroke alignment from config (set via radio buttons in dialog)
                                          // Default to options.innerStrokeAlign if not set in config
                                          var pathStrokeAlignment = config.strokeAlignment !== null && config.strokeAlignment !== undefined 
                                              ? config.strokeAlignment 
                                              : (options.innerStrokeAlign !== undefined ? options.innerStrokeAlign : 1); // Default to center (1)
                                          
                                          // Calculate effective stroke increase
                                          // If we have an actual stroke width from the path, use it
                                          // Otherwise use the pre-calculated strokeThicknessIncrease
                                          var effectiveStrokeIncrease = strokeThicknessIncrease;
                                          
                                          if (pathStrokeWidth > 0) {
                                              // Calculate what the stroke width was at weight 100
                                              var originalInnerStrokeScaled = 0;
                                              
                                              if (options.innerCalcMode !== undefined) {
                                                  // Inner stroke is calculated separately
                                                  var originalInnerStrokeBase;
                                                  if (options.innerCalcMode === 0) { // Auto
                                                      var divisor = options.innerAutoDivisor || 2;
                                                      originalInnerStrokeBase = (STROKE_WIDTHS[100] || 2.22) / divisor;
                                                  } else if (options.innerCalcMode === 1) { // Percent
                                                      var baseStroke = options.innerBaseStroke || 100;
                                                      var increasePerWeight = options.innerIncreasePerWeight || 0;
                                                      originalInnerStrokeBase = baseStroke + (baseStroke * (increasePerWeight / 100) * 0); // weight 100 = 0 multiplier
                                                  } else { // Amount
                                                      var baseStroke = options.innerBaseStroke || 100;
                                                      var increasePerWeight = options.innerIncreasePerWeight || 0;
                                                      originalInnerStrokeBase = baseStroke + (increasePerWeight * 0); // weight 100 = 0 multiplier
                                                  }
                                                  originalInnerStrokeScaled = (originalInnerStrokeBase / 32) * currentSize;
                                              } else {
                                                  // No inner stroke calculation - use outer stroke
                                                  var originalStrokeBase = STROKE_WIDTHS[100] || 2.22;
                                                  originalInnerStrokeScaled = (originalStrokeBase / 32) * currentSize;
                                              }
                                              
                                              // Calculate stroke increase from actual path stroke
                                              effectiveStrokeIncrease = Math.max(0, pathStrokeWidth - originalInnerStrokeScaled);
                                          }
                                          
                                          // Account for outside stroke alignment
                                          // When stroke is outside (alignment = 0), it extends beyond path bounds
                                          // For outside stroke, the stroke extends by the full stroke width beyond the path
                                          // So we need to account for this in the reduction calculation
                                          var isOutsideStroke = (pathStrokeAlignment === 0 || pathStrokeAlignment === StrokeAlignment.OUTSIDEALIGNMENT);
                                          
                                          // Calculate final reductions: base reduction + effective stroke increase
                                          // Both are now in current coordinate space
                                          // When stroke is outside, it extends beyond path bounds by the full stroke width
                                          // For outside stroke, the stroke extends beyond the path, so the visual size includes the stroke
                                          // When reducing, we need to account for the stroke extending outside
                                          var finalReductionTopPixels = 0;
                                          var finalReductionBottomPixels = 0;
                                          
                                          if (config.reduceFromTop) {
                                              finalReductionTopPixels = scaledBaseReductionTop + effectiveStrokeIncrease;
                                              // If outside stroke, the stroke extends beyond the path by the full stroke width
                                              // The stroke increase already accounts for the increase, but for outside strokes,
                                              // the stroke extends beyond the path bounds, so we need to account for that
                                              // Actually, the effectiveStrokeIncrease already accounts for the stroke width increase,
                                              // so we just use it as-is
                                          }
                                          if (config.reduceFromBottom) {
                                              finalReductionBottomPixels = scaledBaseReductionBottom + effectiveStrokeIncrease;
                                              // Same logic for bottom reduction
                                          }
                                          
                                          var finalTotalReductionPixels = finalReductionTopPixels + finalReductionBottomPixels;
                                          
                                          // Skip if no reduction needed
                                          if (finalTotalReductionPixels < 0.001) {
                                              break;
                                          }
                                          
                                          // Calculate new height: current height minus total reduction pixels
                                          // Reduction happens AFTER all scaling, so we work directly in current coordinate space
                                          // finalTotalReductionPixels accounts for:
                                          // 1. Base reduction (scaled to current coordinate space)
                                          // 2. Stroke thickness increase (from actual path stroke or calculated)
                                          
                                          // Simply subtract the reduction from current height
                                          var newHeight = currentHeight - finalTotalReductionPixels;
                                          
                                          // Ensure new height doesn't go below a minimum (e.g., 10% of current height)
                                          var minHeight = currentHeight * 0.1;
                                          newHeight = Math.max(minHeight, newHeight);
                                          
                                          var heightReduction = currentHeight - newHeight;
                                          var reductionFactor = newHeight / currentHeight;
                                          
                                          // Use resize with explicit width/height to avoid aspect ratio constraints
                                          // Resize only height, keep width unchanged (100% = no change to width)
                                          // The boolean parameters control what gets scaled:
                                          // changePositions, changeFillPatterns, changeFillGradients, changeStrokePattern
                                          // We want to scale positions but not patterns/gradients/strokes
                                          
                                          if (config.reduceFromTop && config.reduceFromBottom) {
                                              // Reduce from both - center reduction
                                              // Scale only Y axis, keep X axis at 100%
                                              element.resize(100, reductionFactor * 100, true, false, false, false, 100, Transformation.CENTER);
                                          } else if (config.reduceFromTop) {
                                              // Reduce from top only - keep bottom in place
                                              // Calculate new top position
                                              var newTop = currentBottom + newHeight;
                                              
                                              // Resize from bottom-left anchor point (only Y axis)
                                              element.resize(100, reductionFactor * 100, true, false, false, false, 100, Transformation.BOTTOMLEFT);
                                              
                                              // Adjust to keep bottom in exact place
                                              var newBounds = element.geometricBounds;
                                              if (newBounds && newBounds.length === 4) {
                                                  var actualBottom = newBounds[3];
                                                  var bottomAdjustment = currentBottom - actualBottom;
                                                  if (Math.abs(bottomAdjustment) > 0.001) {
                                                      element.position = [element.position[0], element.position[1] + bottomAdjustment];
                                                  }
                                              }
                                          } else if (config.reduceFromBottom) {
                                              // Reduce from bottom only - keep top in place
                                              // Resize from top-left anchor point (only Y axis)
                                              element.resize(100, reductionFactor * 100, true, false, false, false, 100, Transformation.TOPLEFT);
                                              
                                              // Adjust to keep top in exact place
                                              var newBounds = element.geometricBounds;
                                              if (newBounds && newBounds.length === 4) {
                                                  var actualTop = newBounds[1];
                                                  var topAdjustment = currentTop - actualTop;
                                                  if (Math.abs(topAdjustment) > 0.001) {
                                                      element.position = [element.position[0], element.position[1] + topAdjustment];
                                                  }
                                              }
                                          } else {
                                              // No reduction direction specified, use center
                                              element.resize(100, reductionFactor * 100, true, false, false, false, 100, Transformation.CENTER);
                                          }
                                      }
                                  } catch (e) {
                                      // Skip if resize fails
                                  }
                                  
                                  // Only match first configuration (in case of duplicates)
                                  break;
                              }
                          }
                      }
                  }
              }
          } catch (e) {
              // Skip items that can't be processed
          }
      }
      
      // Start processing from top level
      findAndReducePaths(item, true, false, null);
  } catch (e) {
      // Skip if reduction can't be applied
  }
}

function unlockItems(item) {
  try {
      if (item.locked) item.locked = false;
      
      if (item.typename === 'GroupItem') {
          for (var i = 0; i < item.pageItems.length; i++) {
              unlockItems(item.pageItems[i]);
          }
      } else if (item.typename === 'CompoundPathItem') {
          for (var j = 0; j < item.pathItems.length; j++) {
              if (item.pathItems[j].locked) item.pathItems[j].locked = false;
          }
      }
  } catch (e) {
      // Skip items that can't be unlocked
  }
}

// ============================================================================
// DIALOG UI
// ============================================================================

function showDialog() {
  if (app.documents.length === 0) {
      alert('Please open an icon document first.');
      return;
  }
  
  var doc = app.activeDocument;
  
  if (doc.artboards.length === 0) {
      alert('No artboards found in the document.');
      return;
  }
  
  // ============================================================================
  // SCREEN SIZE DETECTION
  // ============================================================================
  var screenWidth = $.screens[0].right - $.screens[0].left;
  var screenHeight = $.screens[0].bottom - $.screens[0].top;
  var maxWidth = Math.floor(screenWidth * 0.9);
  var maxHeight = Math.floor(screenHeight * 0.9);
  var minWidth = 400;
  var minHeight = 300;
  var desiredWidth = 650;
  var desiredHeight = 700;
  var windowWidth = Math.max(minWidth, Math.min(desiredWidth, maxWidth));
  var windowHeight = Math.max(minHeight, Math.min(desiredHeight, maxHeight));
  
  // ============================================================================
  // CREATE DIALOG WINDOW
  // ============================================================================
  var win = new Window("dialog", "Icon Variant Generator");
  win.orientation = "column";
  win.alignChildren = ["fill", "top"];
  win.spacing = 10;
  win.margins = 12;
  win.preferredSize = [windowWidth, windowHeight];
  
  // Create the tabbed panel
  var tabbedPanel = win.add("tabbedpanel");
  tabbedPanel.alignment = ["fill", "fill"];
  tabbedPanel.preferredSize = [-1, -1];
  
  // Store UI element references
  var artboardCheckboxes = [];
  var weightCheckboxes = [];
  var sizeCheckboxes = [];
  var customSizeInputs = [];
  var customSizeAddBtn, customSizeContainer;
  var fillCb, outsideStrokeCb, shrinkInnerCb;
  var innerFillCb, innerStrokeAlignDropdown, innerCalcModeDropdown, innerAutoDivisorDropdown;
  var innerBaseStrokeInput, innerIncreasePerWeightInput;
  var reduceInnerPathsCb, reduceInnerPathsDimensionDropdown, reduceInnerPathsThresholdInput, reduceInnerPathsAmountInput;
  var artboardOutputCb, svgOutputCb;
  var spacingInput, layoutDropdown, rowsInput, colsInput;
  var exportFolderInput, namingInput, embedRasterCb, organizeByFoldersCb, cssLocationDropdown, fontSubsettingDropdown, coordPrecisionInput;
  var generateBtn;
  
  // ============================================================================
  // TAB 1: ARTBOARD SELECTION
  // ============================================================================
  var tab1 = tabbedPanel.add("tab", undefined, "Artboard Selection");
  tab1.orientation = "column";
  tab1.alignChildren = ["fill", "top"];
  tab1.spacing = 10;
  tab1.margins = 12;
  
  var artboardPanel = tab1.add("panel", undefined, "Select Artboards");
  artboardPanel.orientation = "column";
  artboardPanel.alignChildren = ["fill", "top"];
  artboardPanel.spacing = 6;
  artboardPanel.margins = 10;
  
  // Container for artboard checkboxes in a 4-wide grid format
  var artboardScrollGroup = artboardPanel.add("group");
  artboardScrollGroup.orientation = "column";
  artboardScrollGroup.alignChildren = ["left", "top"];
  artboardScrollGroup.spacing = 4;
  
  // Calculate the maximum width needed for any artboard name
  var maxNameLength = 0;
  for (var calcA = 0; calcA < doc.artboards.length; calcA++) {
      var testName = (calcA + 1) + ". " + doc.artboards[calcA].name;
      if (testName.length > maxNameLength) {
          maxNameLength = testName.length;
      }
  }
  // Set a fixed column width (add some padding for checkbox + spacing)
  var columnWidth = Math.max(120, maxNameLength * 6 + 25);
  
  // Create rows with 4 checkboxes per row in a grid format
  var artboardInputsPerRow = 4;
  var currentArtboardRow = null;
  var artboardRows = [];
  
  // First, create all rows needed
  var numRows = Math.ceil(doc.artboards.length / artboardInputsPerRow);
  for (var r = 0; r < numRows; r++) {
      var row = artboardScrollGroup.add("group");
      row.orientation = "row";
      row.spacing = 6;
      row.alignChildren = ["left", "center"];
      row.alignment = ["fill", "center"];
      artboardRows.push(row);
  }
  
  // Now populate the grid with checkboxes
  for (var a = 0; a < doc.artboards.length; a++) {
      var artboard = doc.artboards[a];
      var artboardName = (a + 1) + ". " + artboard.name;
      
      // Determine which row this checkbox belongs to
      var rowIndex = Math.floor(a / artboardInputsPerRow);
      currentArtboardRow = artboardRows[rowIndex];
      
      // Create checkbox with fixed width for proper grid alignment
      var artboardCb = currentArtboardRow.add("checkbox", undefined, artboardName);
      artboardCb.artboardIndex = a;
      artboardCb.value = false; // No default selection
      artboardCb.preferredSize = [columnWidth, -1]; // Fixed width for column alignment
      artboardCb.alignment = ["left", "center"]; // Left align within fixed width
      artboardCheckboxes.push(artboardCb);
  }
  
  // Fill remaining slots in last row with empty space holders for proper grid alignment
  var lastRowIndex = artboardRows.length - 1;
  var itemsInLastRow = doc.artboards.length % artboardInputsPerRow;
  if (itemsInLastRow > 0 && itemsInLastRow < artboardInputsPerRow) {
      for (var fill = itemsInLastRow; fill < artboardInputsPerRow; fill++) {
          var spacer = artboardRows[lastRowIndex].add("statictext", undefined, "");
          spacer.preferredSize = [columnWidth, -1];
          spacer.alignment = ["left", "center"];
      }
  }
  
  // Select All / Deselect All buttons
  var artboardButtonRow = artboardPanel.add("group");
  artboardButtonRow.orientation = "row";
  artboardButtonRow.spacing = 8;
  artboardButtonRow.alignment = ["center", "center"];
  
  var selectAllBtn = artboardButtonRow.add("button", undefined, "Select All");
  selectAllBtn.preferredSize = [80, 24];
  var deselectAllBtn = artboardButtonRow.add("button", undefined, "Deselect All");
  deselectAllBtn.preferredSize = [80, 24];
  
  selectAllBtn.onClick = function() {
      for (var i = 0; i < artboardCheckboxes.length; i++) {
          artboardCheckboxes[i].value = true;
      }
  };
  
  deselectAllBtn.onClick = function() {
      for (var i = 0; i < artboardCheckboxes.length; i++) {
          artboardCheckboxes[i].value = false;
      }
  };
  
  // ============================================================================
  // TAB 2: WEIGHT AND SIZING
  // ============================================================================
  var tab2 = tabbedPanel.add("tab", undefined, "Weight and Sizing");
  tab2.orientation = "column";
  tab2.alignChildren = ["fill", "top"];
  tab2.spacing = 10;
  tab2.margins = 12;
  
  // Weights Section
  var weightsPanel = tab2.add("panel", undefined, "Weights");
  weightsPanel.orientation = "column";
  weightsPanel.alignChildren = ["fill", "top"];
  weightsPanel.spacing = 6;
  weightsPanel.margins = 10;
  
  var weightValues = [100, 200, 300, 400, 500, 600, 700, 800, 900];
  var weightGrid = weightsPanel.add("group");
  weightGrid.orientation = "row";
  weightGrid.spacing = 8;
  
  var weightCol1 = weightGrid.add("group");
  weightCol1.orientation = "column";
  weightCol1.alignChildren = ["left", "top"];
  weightCol1.spacing = 4;
  
  var weightCol2 = weightGrid.add("group");
  weightCol2.orientation = "column";
  weightCol2.alignChildren = ["left", "top"];
  weightCol2.spacing = 4;
  
  for (var wi = 0; wi < weightValues.length; wi++) {
      var wv = weightValues[wi];
      var targetCol = wi < 5 ? weightCol1 : weightCol2;
      var wcb = targetCol.add("checkbox", undefined, wv + " (" + WEIGHT_NAMES[wv] + ")");
      wcb.weightValue = wv;
      wcb.value = false; // No default selection
      weightCheckboxes.push(wcb);
  }
  
  // Weight Select All / Deselect All buttons
  var weightButtonRow = weightsPanel.add("group");
  weightButtonRow.orientation = "row";
  weightButtonRow.spacing = 8;
  weightButtonRow.alignment = ["center", "center"];
  
  var weightSelectAllBtn = weightButtonRow.add("button", undefined, "Select All");
  weightSelectAllBtn.preferredSize = [80, 24];
  var weightDeselectAllBtn = weightButtonRow.add("button", undefined, "Deselect All");
  weightDeselectAllBtn.preferredSize = [80, 24];
  
  weightSelectAllBtn.onClick = function() {
      for (var i = 0; i < weightCheckboxes.length; i++) {
          weightCheckboxes[i].value = true;
      }
  };
  
  weightDeselectAllBtn.onClick = function() {
      for (var i = 0; i < weightCheckboxes.length; i++) {
          weightCheckboxes[i].value = false;
      }
  };
  
  // Sizes Section
  var sizesPanel = tab2.add("panel", undefined, "Sizes");
  sizesPanel.orientation = "column";
  sizesPanel.alignChildren = ["fill", "top"];
  sizesPanel.spacing = 6;
  sizesPanel.margins = 10;
  
  // Size checkboxes in a grid layout
  var sizeGrid = sizesPanel.add("group");
  sizeGrid.orientation = "column";
  sizeGrid.alignChildren = ["left", "top"];
  sizeGrid.spacing = 4;
  
  // Create rows of 4 checkboxes each
  for (var row = 0; row < Math.ceil(AVAILABLE_SIZES.length / 4); row++) {
      var sizeRow = sizeGrid.add("group");
      sizeRow.orientation = "row";
      sizeRow.spacing = 8;
      for (var col = 0; col < 4; col++) {
          var idx = row * 4 + col;
          if (idx < AVAILABLE_SIZES.length) {
              var size = AVAILABLE_SIZES[idx];
              var sizeCb = sizeRow.add("checkbox", undefined, size + "px");
              sizeCb.sizeValue = size;
              sizeCb.value = false; // No default selection
              sizeCheckboxes.push(sizeCb);
          }
      }
  }
  
  // Size Select All / Deselect All buttons
  var sizeButtonRow = sizesPanel.add("group");
  sizeButtonRow.orientation = "row";
  sizeButtonRow.spacing = 8;
  sizeButtonRow.alignment = ["center", "center"];
  
  var sizeSelectAllBtn = sizeButtonRow.add("button", undefined, "Select All");
  sizeSelectAllBtn.preferredSize = [80, 24];
  var sizeDeselectAllBtn = sizeButtonRow.add("button", undefined, "Deselect All");
  sizeDeselectAllBtn.preferredSize = [80, 24];
  
  sizeSelectAllBtn.onClick = function() {
      for (var i = 0; i < sizeCheckboxes.length; i++) {
          sizeCheckboxes[i].value = true;
      }
  };
  
  sizeDeselectAllBtn.onClick = function() {
      for (var i = 0; i < sizeCheckboxes.length; i++) {
          sizeCheckboxes[i].value = false;
      }
  };
  
  // Custom Sizes Section
  var customSizesPanel = tab2.add("panel", undefined, "Custom Sizes");
  customSizesPanel.orientation = "column";
  customSizesPanel.alignChildren = ["fill", "top"];
  customSizesPanel.spacing = 6;
  customSizesPanel.margins = 10;
  
  // Container for custom size input rows (column that holds rows)
  customSizeContainer = customSizesPanel.add("group");
  customSizeContainer.orientation = "column";
  customSizeContainer.alignChildren = ["left", "top"];
  customSizeContainer.spacing = 4;
  customSizeContainer.alignment = ["fill", "top"];
  
  // Pre-create up to 10 inputs with wrapping (5 per row)
  var maxCustomInputs = 10;
  var inputsPerRow = 5;
  var customSizeRows = []; // Array of row groups
  var customSizeInputGroups = []; // Array of individual input groups (label + input)
  
  // Create first row
  var currentRow = customSizeContainer.add("group");
  currentRow.orientation = "row";
  currentRow.spacing = 6;
  currentRow.alignChildren = ["left", "center"];
  currentRow.alignment = ["fill", "center"];
  customSizeRows.push(currentRow);
  
  // Pre-create all input groups
  for (var preIdx = 0; preIdx < maxCustomInputs; preIdx++) {
      // Check if we need a new row (every 5 inputs)
      if (preIdx > 0 && preIdx % inputsPerRow === 0) {
          currentRow = customSizeContainer.add("group");
          currentRow.orientation = "row";
          currentRow.spacing = 6;
          currentRow.alignChildren = ["left", "center"];
          currentRow.alignment = ["fill", "center"];
          currentRow.visible = false; // Hide new rows initially
          customSizeRows.push(currentRow);
      }
      
      // Create input group (label + input)
      var inputGroup = currentRow.add("group");
      inputGroup.orientation = "row";
      inputGroup.spacing = 4;
      inputGroup.alignChildren = ["left", "center"];
      inputGroup.visible = (preIdx === 0); // Show first one only
      
      var label = inputGroup.add("statictext", undefined, "Size:");
      label.preferredSize = [35, 22];
      
      var sizeInput = inputGroup.add("edittext", undefined, "");
      sizeInput.characters = 6;
      sizeInput.alignment = ["left", "center"];
      sizeInput.preferredSize = [50, 22];
      
      customSizeInputs.push(sizeInput);
      customSizeInputGroups.push(inputGroup);
  }
  
  // Track how many are visible
  var visibleCustomInputs = 1;
  
  // Add button row
  var addButtonRow = customSizesPanel.add("group");
  addButtonRow.orientation = "row";
  addButtonRow.spacing = 8;
  addButtonRow.alignChildren = ["left", "center"];
  customSizeAddBtn = addButtonRow.add("button", undefined, "+ Add Another");
  customSizeAddBtn.preferredSize = [100, 22];
  customSizeAddBtn.enabled = (visibleCustomInputs < maxCustomInputs);
  
  // Add button handler - shows the next input field
  customSizeAddBtn.onClick = function() {
      if (visibleCustomInputs < maxCustomInputs) {
          // Show the next input group
          customSizeInputGroups[visibleCustomInputs].visible = true;
          
          // If this is the first item in a new row, show the row too
          if (visibleCustomInputs % inputsPerRow === 0) {
              var rowIndex = Math.floor(visibleCustomInputs / inputsPerRow);
              if (rowIndex < customSizeRows.length) {
                  customSizeRows[rowIndex].visible = true;
              }
          }
          
          visibleCustomInputs++;
          
          // Disable button if we've reached max
          if (visibleCustomInputs >= maxCustomInputs) {
              customSizeAddBtn.enabled = false;
          }
          
          // Focus the newly shown input
          try {
              customSizeInputs[visibleCustomInputs - 1].active = true;
          } catch (e) {
              // Focus may fail
          }
      }
  };
  
  // ============================================================================
  // TAB 3: ARTBOARD OPTIONS
  // ============================================================================
  var tab3 = tabbedPanel.add("tab", undefined, "Artboard Options");
  tab3.orientation = "column";
  tab3.alignChildren = ["fill", "top"];
  tab3.spacing = 10;
  tab3.margins = 12;
  
  // Scaling Options
  var scalingPanel = tab3.add("panel", undefined, "Scaling Options");
  scalingPanel.orientation = "column";
  scalingPanel.alignChildren = ["fill", "top"];
  scalingPanel.spacing = 6;
  scalingPanel.margins = 10;
  
  fillCb = scalingPanel.add("checkbox", undefined, "Scale to fill artboard");
  fillCb.value = false; // No default selection
  
  // Stroke Options
  var strokePanel = tab3.add("panel", undefined, "Stroke Options");
  strokePanel.orientation = "column";
  strokePanel.alignChildren = ["fill", "top"];
  strokePanel.spacing = 6;
  strokePanel.margins = 10;
  
  outsideStrokeCb = strokePanel.add("checkbox", undefined, "Is outline stroke");
  outsideStrokeCb.value = false;
  
  // Compound Path Options
  var compoundPanel = tab3.add("panel", undefined, "Compound Path Options");
  compoundPanel.orientation = "column";
  compoundPanel.alignChildren = ["fill", "top"];
  compoundPanel.spacing = 6;
  compoundPanel.margins = 10;
  
  shrinkInnerCb = compoundPanel.add("checkbox", undefined, "Shrink inner shapes for compound paths");
  shrinkInnerCb.value = false;
  
  var compoundInfoText = compoundPanel.add("statictext", undefined, "Inner Shape must be grouped for it effect to work", {multiline: true});
  compoundInfoText.preferredSize = [-1, 30];
  
  // Inner Shape Fill Option
  innerFillCb = compoundPanel.add("checkbox", undefined, "Enable fill for inner shapes");
  innerFillCb.value = false;
  
  // Stroke Alignment Option
  var strokeAlignRow = compoundPanel.add("group");
  strokeAlignRow.orientation = "row";
  strokeAlignRow.spacing = 8;
  strokeAlignRow.alignChildren = ["left", "center"];
  strokeAlignRow.add("statictext", undefined, "Inner stroke alignment:");
  innerStrokeAlignDropdown = strokeAlignRow.add("dropdownlist", undefined, ["Outside", "Center", "Inside"]);
  innerStrokeAlignDropdown.selection = 1; // Default to Center
  innerStrokeAlignDropdown.preferredSize = [120, 22];
  
  // Calculation Mode Option
  var calcModeRow = compoundPanel.add("group");
  calcModeRow.orientation = "row";
  calcModeRow.spacing = 8;
  calcModeRow.alignChildren = ["left", "center"];
  calcModeRow.add("statictext", undefined, "Inner stroke calculation:");
  innerCalcModeDropdown = calcModeRow.add("dropdownlist", undefined, ["Auto", "Percent", "Amount"]);
  innerCalcModeDropdown.selection = 0; // Default to Auto
  innerCalcModeDropdown.preferredSize = [120, 22];
  
  // Auto Divisor (only visible when Auto is selected)
  var autoDivisorRow = compoundPanel.add("group");
  autoDivisorRow.orientation = "row";
  autoDivisorRow.spacing = 8;
  autoDivisorRow.alignChildren = ["left", "center"];
  autoDivisorRow.add("statictext", undefined, "Auto divisor:");
  innerAutoDivisorDropdown = autoDivisorRow.add("dropdownlist", undefined, ["2", "3", "4", "5", "6"]);
  innerAutoDivisorDropdown.selection = 0; // Default to 2
  innerAutoDivisorDropdown.preferredSize = [80, 22];
  autoDivisorRow.visible = true; // Visible by default since Auto is default
  
  // Base Stroke Input (only visible when Percent or Amount is selected)
  var baseStrokeRow = compoundPanel.add("group");
  baseStrokeRow.orientation = "row";
  baseStrokeRow.spacing = 8;
  baseStrokeRow.alignChildren = ["left", "center"];
  baseStrokeRow.add("statictext", undefined, "Base stroke thickness:");
  innerBaseStrokeInput = baseStrokeRow.add("edittext", undefined, "100");
  innerBaseStrokeInput.characters = 8;
  innerBaseStrokeInput.preferredSize = [60, 22];
  baseStrokeRow.visible = false; // Hidden by default since Auto is default
  
  // Increase Per Weight Input (only visible when Percent or Amount is selected)
  var increasePerWeightRow = compoundPanel.add("group");
  increasePerWeightRow.orientation = "row";
  increasePerWeightRow.spacing = 8;
  increasePerWeightRow.alignChildren = ["left", "center"];
  increasePerWeightRow.add("statictext", undefined, "Increase per weight:");
  innerIncreasePerWeightInput = increasePerWeightRow.add("edittext", undefined, "10");
  innerIncreasePerWeightInput.characters = 8;
  innerIncreasePerWeightInput.preferredSize = [60, 22];
  increasePerWeightRow.visible = false; // Hidden by default since Auto is default
  
  // Handler to toggle visibility based on calculation mode
  innerCalcModeDropdown.onChange = function() {
      var isAuto = (this.selection && this.selection.index === 0);
      autoDivisorRow.visible = isAuto;
      baseStrokeRow.visible = !isAuto;
      increasePerWeightRow.visible = !isAuto;
  };
  
  // Selective Path Reduction Options
  var reducePathsRow = compoundPanel.add("group");
  reducePathsRow.orientation = "row";
  reducePathsRow.spacing = 8;
  reducePathsRow.alignChildren = ["left", "center"];
  reduceInnerPathsCb = reducePathsRow.add("checkbox", undefined, "Reduce paths/groups inside inner shapes");
  reduceInnerPathsCb.value = false;
  
  var configurePathsBtn = reducePathsRow.add("button", undefined, "Configure Paths...");
  configurePathsBtn.preferredSize = [120, 22];
  configurePathsBtn.enabled = false;
  
  // Store path configuration
  var innerPathsConfig = [];
  
  // Handler to enable/disable configure button
  reduceInnerPathsCb.onClick = function() {
      configurePathsBtn.enabled = this.value;
  };
  
  // Handler for configure paths button - opens dialog to detect and configure paths
  configurePathsBtn.onClick = function() {
      if (app.documents.length === 0 || app.activeDocument.artboards.length === 0) {
          alert("Please select an artboard with inner shapes first.");
          return;
      }
      
      // Detect paths inside inner shapes from the first selected artboard
      var doc = app.activeDocument;
      var artboardIndex = 0; // Use first artboard for detection
      if (artboardCheckboxes.length > 0) {
          // Find first selected artboard
          for (var i = 0; i < artboardCheckboxes.length; i++) {
              if (artboardCheckboxes[i].value) {
                  artboardIndex = artboardCheckboxes[i].artboardIndex;
                  break;
              }
          }
      }
      
      doc.artboards.setActiveArtboardIndex(artboardIndex);
      doc.selectObjectsOnActiveArtboard();
      var sourceItems = doc.selection;
      
      if (sourceItems.length === 0) {
          alert("No items found on artboard. Please ensure your icon is on the artboard.");
          return;
      }
      
      // Group items for detection
      // Store original parent of each item before moving them
      // We need to preserve the layer structure (e.g., compound shape layer with inner/outer groups)
      var itemParents = [];
      var tempGroup = doc.groupItems.add();
      
      // Move items in reverse order to tempGroup (so first item ends up last in tempGroup)
      for (var j = sourceItems.length - 1; j >= 0; j--) {
          var item = sourceItems[j];
          // Store the original parent before moving
          itemParents.push({
              item: item,
              parent: item.parent
          });
          item.move(tempGroup, ElementPlacement.PLACEATBEGINNING);
      }
      
      // Detect paths inside inner shapes
      var detectedPaths = detectPathsInsideInnerShapes(tempGroup);
      
      // Restore items to their original parents
      // Restore in reverse order (from end of array) so items go back in original order
      // This preserves the layer hierarchy structure
      for (var k = itemParents.length - 1; k >= 0; k--) {
          try {
              var itemInfo = itemParents[k];
              // Check if parent still exists and is valid
              if (itemInfo.item && itemInfo.parent && itemInfo.parent.typename) {
                  // Use PLACEATBEGINNING to maintain the original order within the parent
                  // Since we're restoring backwards, this will restore items in their original positions
                  itemInfo.item.move(itemInfo.parent, ElementPlacement.PLACEATBEGINNING);
              } else {
                  // Fallback: move to document if original parent no longer exists
                  itemInfo.item.move(doc, ElementPlacement.PLACEATEND);
              }
          } catch (e) {
              // If restoration fails, try moving to document
              try {
                  itemParents[k].item.move(doc, ElementPlacement.PLACEATEND);
              } catch (e2) {
                  // Skip if item can't be restored
              }
          }
      }
      tempGroup.remove();
      doc.selection = null;
      
      if (detectedPaths.length === 0) {
          alert("No paths detected inside inner shapes. Make sure your inner shapes are grouped and contain paths.");
          return;
      }
      
      // Show configuration dialog
      showPathConfigurationDialog(detectedPaths);
  };
  
  // ============================================================================
  // TAB 4: OUTPUT TYPE
  // ============================================================================
  var tab4 = tabbedPanel.add("tab", undefined, "Output Type");
  tab4.orientation = "column";
  tab4.alignChildren = ["fill", "top"];
  tab4.spacing = 10;
  tab4.margins = 12;
  
  // Output Selection
  var outputSelectionPanel = tab4.add("panel", undefined, "Output Selection");
  outputSelectionPanel.orientation = "column";
  outputSelectionPanel.alignChildren = ["fill", "top"];
  outputSelectionPanel.spacing = 6;
  outputSelectionPanel.margins = 10;
  
  artboardOutputCb = outputSelectionPanel.add("checkbox", undefined, "Generate Artboards");
  svgOutputCb = outputSelectionPanel.add("checkbox", undefined, "Export to SVG");
  
  // Artboard Generation Options (shown when Generate Artboards is checked)
  var artboardOptionsPanel = tab4.add("panel", undefined, "Artboard Generation Options");
  artboardOptionsPanel.orientation = "column";
  artboardOptionsPanel.alignChildren = ["fill", "top"];
  artboardOptionsPanel.spacing = 8;
  artboardOptionsPanel.margins = 10;
  artboardOptionsPanel.visible = false;
  
  var spacingRow = artboardOptionsPanel.add("group");
  spacingRow.orientation = "row";
  spacingRow.spacing = 8;
  spacingRow.alignChildren = ["left", "center"];
  spacingRow.add("statictext", undefined, "Spacing between artboards:");
  spacingInput = spacingRow.add("edittext", undefined, "20");
  spacingInput.characters = 6;
  spacingRow.add("statictext", undefined, "px");
  
  var layoutRow = artboardOptionsPanel.add("group");
  layoutRow.orientation = "row";
  layoutRow.spacing = 8;
  layoutRow.alignChildren = ["left", "center"];
  layoutRow.add("statictext", undefined, "Layout arrangement:");
  layoutDropdown = layoutRow.add("dropdownlist", undefined, ["Grid (Rows by Columns)", "Horizontal", "Vertical"]);
  layoutDropdown.selection = 0;
  layoutDropdown.preferredSize = [180, 22];
  
  var rowsRow = artboardOptionsPanel.add("group");
  rowsRow.orientation = "row";
  rowsRow.spacing = 8;
  rowsRow.alignChildren = ["left", "center"];
  rowsRow.visible = false; // Only visible for Grid layout
  rowsRow.add("statictext", undefined, "Rows:");
  rowsInput = rowsRow.add("edittext", undefined, "");
  rowsInput.characters = 6;
  
  var colsRow = artboardOptionsPanel.add("group");
  colsRow.orientation = "row";
  colsRow.spacing = 8;
  colsRow.alignChildren = ["left", "center"];
  colsRow.visible = false; // Only visible for Grid layout
  colsRow.add("statictext", undefined, "Columns:");
  colsInput = colsRow.add("edittext", undefined, "");
  colsInput.characters = 6;
  
  // SVG Export Options (shown when Export to SVG is checked)
  var svgOptionsPanel = tab4.add("panel", undefined, "SVG Export Options");
  svgOptionsPanel.orientation = "column";
  svgOptionsPanel.alignChildren = ["fill", "top"];
  svgOptionsPanel.spacing = 8;
  svgOptionsPanel.margins = 10;
  svgOptionsPanel.visible = false;
  
  var exportFolderRow = svgOptionsPanel.add("group");
  exportFolderRow.orientation = "row";
  exportFolderRow.spacing = 8;
  exportFolderRow.alignChildren = ["left", "center"];
  exportFolderRow.add("statictext", undefined, "Export folder path:");
  exportFolderInput = exportFolderRow.add("edittext", undefined, "~/Desktop/icons");
  exportFolderInput.characters = 30;
  exportFolderInput.alignment = ["fill", "center"];
  var browseBtn = exportFolderRow.add("button", undefined, "Browse...");
  browseBtn.preferredSize = [70, 22];
  
  var namingRow = svgOptionsPanel.add("group");
  namingRow.orientation = "row";
  namingRow.spacing = 8;
  namingRow.alignChildren = ["left", "center"];
  namingRow.add("statictext", undefined, "Naming pattern:");
  namingInput = namingRow.add("edittext", undefined, "{name}_{weight}_{size}");
  namingInput.characters = 30;
  namingInput.alignment = ["fill", "center"];
  
  var embedRasterRow = svgOptionsPanel.add("group");
  embedRasterRow.orientation = "row";
  embedRasterRow.spacing = 8;
  embedRasterRow.alignChildren = ["left", "center"];
  embedRasterCb = embedRasterRow.add("checkbox", undefined, "Embed raster images");
  embedRasterCb.value = false;
  
  var organizeFoldersRow = svgOptionsPanel.add("group");
  organizeFoldersRow.orientation = "row";
  organizeFoldersRow.spacing = 8;
  organizeFoldersRow.alignChildren = ["left", "center"];
  organizeByFoldersCb = organizeFoldersRow.add("checkbox", undefined, "Organize by folders (name/size)");
  organizeByFoldersCb.value = false;
  
  var cssLocationRow = svgOptionsPanel.add("group");
  cssLocationRow.orientation = "row";
  cssLocationRow.spacing = 8;
  cssLocationRow.alignChildren = ["left", "center"];
  cssLocationRow.add("statictext", undefined, "CSS properties location:");
  cssLocationDropdown = cssLocationRow.add("dropdownlist", undefined, ["Presentation Attributes", "Style Elements", "Entities"]);
  cssLocationDropdown.selection = 0;
  cssLocationDropdown.preferredSize = [180, 22];
  
  var fontSubsettingRow = svgOptionsPanel.add("group");
  fontSubsettingRow.orientation = "row";
  fontSubsettingRow.spacing = 8;
  fontSubsettingRow.alignChildren = ["left", "center"];
  fontSubsettingRow.add("statictext", undefined, "Font subsetting:");
  fontSubsettingDropdown = fontSubsettingRow.add("dropdownlist", undefined, ["None", "Glyphs Used", "Common English", "All Glyphs"]);
  fontSubsettingDropdown.selection = 0;
  fontSubsettingDropdown.preferredSize = [180, 22];
  
  var coordPrecisionRow = svgOptionsPanel.add("group");
  coordPrecisionRow.orientation = "row";
  coordPrecisionRow.spacing = 8;
  coordPrecisionRow.alignChildren = ["left", "center"];
  coordPrecisionRow.add("statictext", undefined, "Coordinate precision:");
  coordPrecisionInput = coordPrecisionRow.add("edittext", undefined, "2");
  coordPrecisionInput.characters = 3;
  
  // Event handlers for output type checkboxes
  function updateOutputPanels() {
      artboardOptionsPanel.visible = artboardOutputCb.value;
      svgOptionsPanel.visible = svgOutputCb.value;
      updateGenerateButton();
  }
  
  artboardOutputCb.onClick = function() {
      updateOutputPanels();
  };
  
  svgOutputCb.onClick = function() {
      updateOutputPanels();
  };
  
  // Layout dropdown handler
  layoutDropdown.onChange = function() {
      var isGrid = (this.selection && this.selection.index === 0);
      rowsRow.visible = isGrid;
      colsRow.visible = isGrid;
  };
  
  // Browse button handler
  browseBtn.onClick = function() {
      var folder = Folder.selectDialog("Select export folder");
      if (folder) {
          exportFolderInput.text = folder.fsName;
      }
  };
  
  // ============================================================================
  // BUTTONS (Outside tabs, at bottom of window)
  // ============================================================================
  var buttonGroup = win.add("group");
  buttonGroup.orientation = "row";
  buttonGroup.spacing = 8;
  buttonGroup.alignment = ["right", "center"];
  
  generateBtn = buttonGroup.add("button", undefined, "Generate");
  generateBtn.preferredSize = [80, 24];
  generateBtn.enabled = false;
  
  var cancelBtn = buttonGroup.add("button", undefined, "Cancel");
  cancelBtn.preferredSize = [80, 24];
  
  // Function to update Generate button state
  function updateGenerateButton() {
      var hasOutput = artboardOutputCb.value || svgOutputCb.value;
      generateBtn.enabled = hasOutput;
  }
  
  // Initial update
  updateGenerateButton();
  
  // ============================================================================
  // VALIDATION AND DATA COLLECTION
  // ============================================================================
  
  function getSelectedArtboards() {
      var selected = [];
      for (var i = 0; i < artboardCheckboxes.length; i++) {
          if (artboardCheckboxes[i].value) {
              selected.push(artboardCheckboxes[i].artboardIndex);
          }
      }
      return selected;
  }
  
  function getSelectedWeights() {
      var weights = [];
      for (var i = 0; i < weightCheckboxes.length; i++) {
          if (weightCheckboxes[i].value) {
              weights.push(weightCheckboxes[i].weightValue);
          }
      }
      return weights;
  }
  
  function getSelectedSizes() {
      var sizes = [];
      // Get sizes from checkboxes
      for (var i = 0; i < sizeCheckboxes.length; i++) {
          if (sizeCheckboxes[i].value) {
              sizes.push(sizeCheckboxes[i].sizeValue);
          }
      }
      // Get sizes from custom size inputs
      for (var j = 0; j < customSizeInputs.length; j++) {
          try {
              var inputText = customSizeInputs[j].text;
              if (inputText) {
                  var sizeValue = parseInt(String(inputText).replace(/^\s+|\s+$/g, ''), 10);
                  if (sizeValue > 0 && !isNaN(sizeValue)) {
                      sizes.push(sizeValue);
                  }
              }
          } catch (e) {
              // Skip invalid inputs
          }
      }
      // Deduplicate
      var uniqueSizes = [];
      var seen = {};
      for (var k = 0; k < sizes.length; k++) {
          var size = sizes[k];
          if (!seen[size]) {
              seen[size] = true;
              uniqueSizes.push(size);
          }
      }
      return uniqueSizes;
  }
  
  function validateInputs() {
      var selectedArtboards = getSelectedArtboards();
      if (selectedArtboards.length === 0) {
          alert("Please select at least one artboard.");
          return false;
      }
      
      var selectedWeights = getSelectedWeights();
      if (selectedWeights.length === 0) {
          alert("Please select at least one weight.");
          return false;
      }
      
      var selectedSizes = getSelectedSizes();
      if (selectedSizes.length === 0) {
          alert("Please select at least one size (from checkboxes or custom sizes).");
          return false;
      }
      
      if (!artboardOutputCb.value && !svgOutputCb.value) {
          alert("Please select at least one output type.");
          return false;
      }
      
      if (artboardOutputCb.value) {
          var spacingText = spacingInput.text;
          var spacing = (spacingText && !isNaN(parseFloat(spacingText))) ? parseFloat(spacingText) : NaN;
          if (isNaN(spacing) || spacing < 0) {
              alert("Please enter a valid spacing value (positive number).");
              return false;
          }
      }
      
      if (svgOutputCb.value) {
          var exportFolderText = exportFolderInput.text;
          // Safely convert to string and check if it's empty
          var exportFolderStr = (exportFolderText != null) ? String(exportFolderText) : "";
          if (!exportFolderStr || exportFolderStr.replace(/^\s+|\s+$/g, '') === '') {
              alert("Please enter an export folder path.");
              return false;
          }
      }
      
      return true;
  }
  
  // ============================================================================
  // GENERATE BUTTON HANDLER
  // ============================================================================
  generateBtn.onClick = function() {
      try {
          if (!validateInputs()) {
              return;
          }
          
          var selectedArtboards = getSelectedArtboards();
          var selectedWeights = getSelectedWeights();
          var selectedSizes = getSelectedSizes();
          
          // Sort sizes and weights
          selectedSizes.sort(function(a, b) { return a - b; });
          selectedWeights.sort(function(a, b) { return a - b; });
          
          var totalProcessed = 0;
          var errors = [];
          
          for (var ab = 0; ab < selectedArtboards.length; ab++) {
              var artboardIndex = selectedArtboards[ab];
              var artboard = doc.artboards[artboardIndex];
              var baseName = artboard.name.match(/^Artboard \d+$/) ? doc.name.replace(/\.[^.]+$/, '') : artboard.name;
              
              var options = {
                  name: baseName,
                  sizes: selectedSizes,
                  weights: selectedWeights,
                  sourceArtboardIndex: artboardIndex,
                  fillArtboard: fillCb.value,
                  padding: 0,
                  paddingIsPercent: false,
                  isOutsideStroke: outsideStrokeCb.value,
                  shrinkInnerShapes: shrinkInnerCb.value,
                  innerShapeFill: innerFillCb.value,
                  innerStrokeAlign: innerStrokeAlignDropdown.selection ? innerStrokeAlignDropdown.selection.index : 1,
                  innerCalcMode: innerCalcModeDropdown.selection ? innerCalcModeDropdown.selection.index : 0,
                  innerAutoDivisor: innerAutoDivisorDropdown.selection ? parseFloat(innerAutoDivisorDropdown.selection.text) || 2 : 2,
                  innerBaseStroke: parseFloat(innerBaseStrokeInput.text) || 100,
                  innerIncreasePerWeight: parseFloat(innerIncreasePerWeightInput.text) || 0,
                  reduceInnerPaths: reduceInnerPathsCb.value,
                  innerPathsConfig: innerPathsConfig || []
              };
              
              if (artboardOutputCb.value) {
                  var spacingText = spacingInput.text;
                  options.spacing = (spacingText && !isNaN(parseFloat(spacingText))) ? parseFloat(spacingText) : 20;
                  options.layout = layoutDropdown.selection ? layoutDropdown.selection.index : 0;
                  var rowsText = rowsInput.text;
                  options.rows = (rowsText && typeof rowsText === 'string' && rowsText.trim()) ? parseInt(rowsText, 10) : null;
                  var colsText = colsInput.text;
                  options.columns = (colsText && typeof colsText === 'string' && colsText.trim()) ? parseInt(colsText, 10) : null;
                  
                  try {
                      generateArtboards(options);
                      totalProcessed += selectedSizes.length * selectedWeights.length;
                  } catch (e) {
                      errors.push("Artboard " + artboard.name + ": " + (e.message || e.toString()));
                  }
              }
              
              if (svgOutputCb.value) {
                  var exportFolderText = exportFolderInput.text;
                  // Safely convert to string and trim
                  var exportFolderStr = (exportFolderText != null) ? String(exportFolderText) : "";
                  options.exportFolder = exportFolderStr.replace(/^\s+|\s+$/g, '');
                  var namingText = namingInput.text;
                  // Safely convert to string and trim
                  var namingStr = (namingText != null) ? String(namingText) : "";
                  var namingTrimmed = namingStr.replace(/^\s+|\s+$/g, '');
                  options.namingPattern = namingTrimmed || "{name}_{weight}_{size}";
                  options.embedRasterImages = embedRasterCb.value;
                  options.organizeByFolders = organizeByFoldersCb.value;
                  options.cssProperties = cssLocationDropdown.selection ? cssLocationDropdown.selection.index : 0;
                  options.fontSubsetting = fontSubsettingDropdown.selection ? fontSubsettingDropdown.selection.index : 0;
                  var coordPrecisionText = coordPrecisionInput.text;
                  options.coordinatePrecision = (coordPrecisionText && !isNaN(parseInt(coordPrecisionText, 10))) ? parseInt(coordPrecisionText, 10) : 2;
                  
                  try {
                      var exportResult = exportToSVG(options);
                      if (exportResult) {
                          totalProcessed += exportResult.count;
                          if (exportResult.errors && exportResult.errors.length > 0) {
                              for (var errIdx = 0; errIdx < exportResult.errors.length; errIdx++) {
                                  errors.push(exportResult.errors[errIdx]);
                              }
                          }
                      } else {
                          totalProcessed += selectedSizes.length * selectedWeights.length;
                      }
                  } catch (e) {
                      errors.push("SVG Export " + artboard.name + ": " + (e.message || e.toString()));
                  }
              }
          }
          
          // Show single summary at the end
          if (totalProcessed > 0 || errors.length > 0) {
              var message = "Done!\n\n";
              if (totalProcessed > 0) {
                  message += "Processed " + totalProcessed + " variant" + (totalProcessed !== 1 ? "s" : "");
                  if (svgOutputCb.value && selectedArtboards.length > 0) {
                      // Get export folder from first artboard's result
                      try {
                          var firstExportFolderText = exportFolderInput.text;
                          var firstExportFolderStr = (firstExportFolderText != null) ? String(firstExportFolderText) : "";
                          var firstExportFolder = firstExportFolderStr.replace(/^\s+|\s+$/g, '');
                          if (firstExportFolder.indexOf('~') === 0) {
                              firstExportFolder = Folder.userData.parent.fsName + firstExportFolder.substring(1);
                          }
                          message += "\n\nExported to:\n" + firstExportFolder;
                      } catch (e) {
                          // Skip if we can't get folder path
                      }
                  }
              }
              if (errors.length > 0) {
                  message += "\n\nErrors (" + errors.length + "):\n" + errors.slice(0, 5).join("\n");
                  if (errors.length > 5) {
                      message += "\n... and " + (errors.length - 5) + " more";
                  }
              }
              alert(message);
          }
          
          win.close(1);
      } catch (e) {
          alert("Error: " + (e.message || e.toString()) + "\n\nLine: " + (e.line || "unknown"));
      }
  };
  
  cancelBtn.onClick = function() {
      win.close(0);
  };
  
  // Set initial tab selection
  tabbedPanel.selection = tab1;
  
  // Force layout update before showing
  if (win.layout) {
      win.layout.layout();
  }
  
  // Center and show the window
  win.center();
  var result = win.show();
}

// ============================================================================
// ARTBOARD GENERATION
// ============================================================================

function generateArtboards(options) {
  var doc = app.activeDocument;
  var sourceIndex = options.sourceArtboardIndex || 0;
  
  var sourceArtboard = doc.artboards[sourceIndex];
  var sourceRect = sourceArtboard.artboardRect;
  var sourceLeft = sourceRect[0];
  var sourceTop = sourceRect[1];
  var sourceRight = sourceRect[2];
  var sourceBottom = sourceRect[3];
  var sourceWidth = sourceRight - sourceLeft;
  var sourceHeight = sourceTop - sourceBottom;
  
  doc.artboards.setActiveArtboardIndex(sourceIndex);
  doc.selectObjectsOnActiveArtboard();
  
  var sourceItems = doc.selection;
  
  if (sourceItems.length === 0) {
      alert('No items found on artboard "' + sourceArtboard.name + '".\n\nMake sure your icon paths are on this artboard.');
      return;
  }
  
  // Group source items for duplication
  var sourceGroup = doc.groupItems.add();
  for (var i = sourceItems.length - 1; i >= 0; i--) {
      sourceItems[i].move(sourceGroup, ElementPlacement.PLACEATBEGINNING);
  }
  
  var sourceGroupBounds = sourceGroup.geometricBounds;
  var sourceIconWidth = sourceGroupBounds[2] - sourceGroupBounds[0];
  var sourceIconHeight = sourceGroupBounds[1] - sourceGroupBounds[3];
  
  // Get original stroke width for compound shape scaling
  var originalStrokeWidth = getOriginalStrokeWidth(sourceGroup);
  if (!originalStrokeWidth || originalStrokeWidth <= 0) {
      originalStrokeWidth = STROKE_WIDTHS[400] || 3.91;
  }
  
  var spacing = options.spacing || 20;
  var count = 0;
  
  // Find the lowest point of all existing artboards
  var lowestY = sourceBottom;
  for (var ab = 0; ab < doc.artboards.length; ab++) {
      var abRect = doc.artboards[ab].artboardRect;
      var abBottom = abRect[3];
      if (abBottom < lowestY) {
          lowestY = abBottom;
      }
  }
  
  var currentX = sourceLeft;
  var currentY = lowestY - spacing;
  
  // Grid layout: sizes as rows, weights as columns
  for (var s = 0; s < options.sizes.length; s++) {
      var size = options.sizes[s];
      currentY -= size;
      currentX = sourceLeft;
      
      for (var w = 0; w < options.weights.length; w++) {
          var weight = options.weights[w];
          var scaleFactor;
          var strokeWidth;
          
          if (options.fillArtboard) {
              var paddingPx = options.paddingIsPercent 
                  ? (size * options.padding / 100) 
                  : (options.padding / 32) * size;
              
              var baseStroke = STROKE_WIDTHS[weight] || STROKE_WIDTHS[400];
              strokeWidth = (baseStroke / 32) * size;
              
              var strokeAdjustment = options.isOutsideStroke ? strokeWidth * 2 : strokeWidth;
              var availableSize = size - (paddingPx * 2) - strokeAdjustment;
              var scaleToFitWidth = availableSize / sourceIconWidth;
              var scaleToFitHeight = availableSize / sourceIconHeight;
              scaleFactor = Math.min(scaleToFitWidth, scaleToFitHeight);
              
              if (scaleFactor <= 0) scaleFactor = 0.1;
          } else {
              // For outline strokes, even when not filling artboard, we need to account for stroke extending outside
              if (options.isOutsideStroke) {
                  var baseStroke = STROKE_WIDTHS[weight] || STROKE_WIDTHS[400];
                  strokeWidth = (baseStroke / 32) * size;
                  // Scale down to account for stroke extending outside (strokeWidth * 2 on both sides)
                  var strokeAdjustment = strokeWidth * 2;
                  var availableSize = size - strokeAdjustment;
                  // Use sourceIconWidth and sourceIconHeight (icon bounds) and take minimum for consistency
                  var scaleToFitWidth = availableSize / sourceIconWidth;
                  var scaleToFitHeight = availableSize / sourceIconHeight;
                  scaleFactor = Math.min(scaleToFitWidth, scaleToFitHeight);
                  
                  if (scaleFactor <= 0) scaleFactor = 0.1;
              } else {
                  scaleFactor = size / sourceWidth;
                  strokeWidth = calculateStroke(weight, size);
              }
          }
          
          var artboardTop = currentY + size;
          var artboardBottom = currentY;
          var artboardRect = [currentX, artboardTop, currentX + size, artboardBottom];
          
          var newArtboard = doc.artboards.add(artboardRect);
          newArtboard.name = options.name + '_' + weight + '_' + size + 'x' + size;
          
          var newGroup = sourceGroup.duplicate();
          newGroup.resize(
              scaleFactor * 100, scaleFactor * 100,
              true, true, true, true,
              scaleFactor * 100,
              Transformation.CENTER
          );
          
          var groupBounds = newGroup.geometricBounds;
          var groupWidth = groupBounds[2] - groupBounds[0];
          var groupHeight = groupBounds[1] - groupBounds[3];
          
          var artboardCenterX = currentX + (size / 2);
          var artboardCenterY = currentY + (size / 2);
          
          var newLeft = artboardCenterX - (groupWidth / 2);
          var newTop = artboardCenterY + (groupHeight / 2);
          
          newGroup.position = [newLeft, newTop];
          applyStrokeWidth(newGroup, strokeWidth);
          
          // Scale inner elements for compound shapes if enabled
          if (options.shrinkInnerShapes && originalStrokeWidth > 0 && strokeWidth > 0) {
              var originalStrokeScaled = originalStrokeWidth * (size / sourceWidth);
              var strokeIncrease = strokeWidth - originalStrokeScaled;
              if (strokeIncrease > 0.001) {
                  var outerSize = getLargestElementSize(newGroup);
                  var strokeIncreasePerSide = strokeIncrease / 2;
                  var innerScaleFactor;
                  // Multiply reduction ratio by 1.3 to shrink inner elements more aggressively
                  var shrinkMultiplier = 1.3;
                  if (outerSize > 0) {
                      var reductionRatio = (strokeIncreasePerSide / outerSize) * shrinkMultiplier;
                      innerScaleFactor = Math.max(0.5, 1 - reductionRatio);
                  } else {
                      var reductionRatio = (strokeIncrease / size) * shrinkMultiplier;
                      innerScaleFactor = Math.max(0.5, 1 - reductionRatio);
                  }
                  
                  scaleInnerElements(newGroup, innerScaleFactor, true, outerSize);
                  var updatedBounds = newGroup.geometricBounds;
                  var updatedWidth = updatedBounds[2] - updatedBounds[0];
                  var updatedHeight = updatedBounds[1] - updatedBounds[3];
                  var updatedLeft = artboardCenterX - (updatedWidth / 2);
                  var updatedTop = artboardCenterY + (updatedHeight / 2);
                  newGroup.position = [updatedLeft, updatedTop];
              }
          }
          
          // Scale inner shapes based on inner stroke width increase (if advanced options are enabled)
          if (options.innerCalcMode !== undefined) {
              // Get original inner stroke width from source group
              var originalInnerStrokeWidth = getOriginalInnerStrokeWidth(sourceGroup);
              if (!originalInnerStrokeWidth || originalInnerStrokeWidth <= 0) {
                  // If no inner stroke found, use a default based on outer stroke
                  originalInnerStrokeWidth = originalStrokeWidth * 0.5;
              }
              
              // Scale original inner stroke to current size
              var originalInnerStrokeScaled = originalInnerStrokeWidth * (size / sourceWidth);
              
              // Calculate new inner stroke width based on advanced options
              var calculatedInnerStroke;
              if (options.innerCalcMode === 0) { // Auto
                  var divisor = options.innerAutoDivisor || 2;
                  var baseStrokeWidth = STROKE_WIDTHS[weight] || STROKE_WIDTHS[400];
                  calculatedInnerStroke = baseStrokeWidth / divisor;
              } else if (options.innerCalcMode === 1) { // Percent
                  var baseStroke = options.innerBaseStroke || 100;
                  var weightMultiplier = (weight - 100) / 100;
                  var increasePerWeight = options.innerIncreasePerWeight || 0;
                  calculatedInnerStroke = baseStroke + (baseStroke * (increasePerWeight / 100) * weightMultiplier);
              } else { // Amount
                  var baseStroke = options.innerBaseStroke || 100;
                  var weightMultiplier = (weight - 100) / 100;
                  var increasePerWeight = options.innerIncreasePerWeight || 0;
                  calculatedInnerStroke = baseStroke + (increasePerWeight * weightMultiplier);
              }
              
              // Scale to current size
              var newInnerStrokeWidth = (calculatedInnerStroke / 32) * size;
              
              // If new inner stroke is larger, scale down inner shapes
              var innerStrokeIncrease = newInnerStrokeWidth - originalInnerStrokeScaled;
              if (innerStrokeIncrease > 0.001) {
                  var outerSize = getLargestElementSize(newGroup);
                  var innerStrokeIncreasePerSide = innerStrokeIncrease / 2;
                  var innerScaleFactorFromStroke;
                  var shrinkMultiplier = 1.3;
                  
                  if (outerSize > 0) {
                      var reductionRatio = (innerStrokeIncreasePerSide / outerSize) * shrinkMultiplier;
                      innerScaleFactorFromStroke = Math.max(0.5, 1 - reductionRatio);
                  } else {
                      var reductionRatio = (innerStrokeIncrease / size) * shrinkMultiplier;
                      innerScaleFactorFromStroke = Math.max(0.5, 1 - reductionRatio);
                  }
                  
                  // Apply additional scaling to inner shapes
                  scaleInnerElements(newGroup, innerScaleFactorFromStroke, true, outerSize);
                  var updatedBounds = newGroup.geometricBounds;
                  var updatedWidth = updatedBounds[2] - updatedBounds[0];
                  var updatedHeight = updatedBounds[1] - updatedBounds[3];
                  var updatedLeft = artboardCenterX - (updatedWidth / 2);
                  var updatedTop = artboardCenterY + (updatedHeight / 2);
                  newGroup.position = [updatedLeft, updatedTop];
              }
          }
          
          // Apply inner shape styling (fill, stroke alignment, stroke width)
          if (options.innerShapeFill || options.innerStrokeAlign !== undefined || options.innerCalcMode !== undefined) {
              applyInnerShapeStyling(newGroup, options, strokeWidth, weight, size);
          }
          
          // Reduce paths/groups inside inner shapes if enabled
          if (options.reduceInnerPaths) {
              reducePathsInsideInnerShapes(newGroup, options, weight, size);
              // Recalculate bounds and reposition after path reduction
              var finalBounds = newGroup.geometricBounds;
              var finalWidth = finalBounds[2] - finalBounds[0];
              var finalHeight = finalBounds[1] - finalBounds[3];
              var finalLeft = artboardCenterX - (finalWidth / 2);
              var finalTop = artboardCenterY + (finalHeight / 2);
              newGroup.position = [finalLeft, finalTop];
          }
          
          currentX += size + spacing;
          count++;
      }
      
      currentY -= spacing;
  }
  
  // Restore original items
  while (sourceGroup.pageItems.length > 0) {
      sourceGroup.pageItems[0].move(doc, ElementPlacement.PLACEATEND);
  }
  sourceGroup.remove();
  
  doc.selection = null;
}

// ============================================================================
// SVG EXPORT
// ============================================================================

function exportToSVG(options) {
  var doc = app.activeDocument;
  var sourceIndex = options.sourceArtboardIndex || 0;
  
  var sourceArtboard = doc.artboards[sourceIndex];
  var sourceRect = sourceArtboard.artboardRect;
  var sourceWidth = sourceRect[2] - sourceRect[0];
  var sourceHeight = sourceRect[1] - sourceRect[3];
  
  doc.artboards.setActiveArtboardIndex(sourceIndex);
  doc.selectObjectsOnActiveArtboard();
  
  var sourceItems = doc.selection;
  
  if (sourceItems.length === 0) {
      alert('No items found on artboard "' + sourceArtboard.name + '".');
      return;
  }
  
  // Create or verify export folder
  var exportPath = options.exportFolder;
  if (exportPath.indexOf('~') === 0) {
      exportPath = Folder.userData.parent.fsName + exportPath.substring(1);
  }
  
  var exportFolder = new Folder(exportPath);
  if (!exportFolder.exists) {
      var created = exportFolder.create();
      if (!created) {
          alert('Could not create export folder:\n' + exportPath);
          return;
      }
  }
  
  // Group source items for duplication
  var sourceGroup = doc.groupItems.add();
  for (var i = sourceItems.length - 1; i >= 0; i--) {
      sourceItems[i].move(sourceGroup, ElementPlacement.PLACEATBEGINNING);
  }
  
  var sourceGroupBounds = sourceGroup.geometricBounds;
  var sourceIconWidth = sourceGroupBounds[2] - sourceGroupBounds[0];
  var sourceIconHeight = sourceGroupBounds[1] - sourceGroupBounds[3];
  
  // Get original stroke width for compound shape scaling
  var originalStrokeWidth = getOriginalStrokeWidth(sourceGroup);
  if (!originalStrokeWidth || originalStrokeWidth <= 0) {
      originalStrokeWidth = STROKE_WIDTHS[400] || 3.91;
  }
  
  var count = 0;
  var errors = [];
  
  // Create a temporary document for each export
  for (var s = 0; s < options.sizes.length; s++) {
      var size = options.sizes[s];
      
      for (var w = 0; w < options.weights.length; w++) {
          var weight = options.weights[w];
          var scaleFactor;
          var strokeWidth;
          
          if (options.fillArtboard) {
              var paddingPx = options.paddingIsPercent 
                  ? (size * options.padding / 100) 
                  : (options.padding / 32) * size;
              
              var baseStroke = STROKE_WIDTHS[weight] || STROKE_WIDTHS[400];
              strokeWidth = (baseStroke / 32) * size;
              
              var strokeAdjustment = options.isOutsideStroke ? strokeWidth * 2 : strokeWidth;
              var availableSize = size - (paddingPx * 2) - strokeAdjustment;
              var scaleToFitWidth = availableSize / sourceIconWidth;
              var scaleToFitHeight = availableSize / sourceIconHeight;
              scaleFactor = Math.min(scaleToFitWidth, scaleToFitHeight);
              
              if (scaleFactor <= 0) scaleFactor = 0.1;
          } else {
              // For outline strokes, even when not filling artboard, we need to account for stroke extending outside
              if (options.isOutsideStroke) {
                  var baseStroke = STROKE_WIDTHS[weight] || STROKE_WIDTHS[400];
                  strokeWidth = (baseStroke / 32) * size;
                  // Scale down to account for stroke extending outside (strokeWidth * 2 on both sides)
                  var strokeAdjustment = strokeWidth * 2;
                  var availableSize = size - strokeAdjustment;
                  // Use sourceIconWidth and sourceIconHeight (icon bounds) and take minimum for consistency
                  var scaleToFitWidth = availableSize / sourceIconWidth;
                  var scaleToFitHeight = availableSize / sourceIconHeight;
                  scaleFactor = Math.min(scaleToFitWidth, scaleToFitHeight);
                  
                  if (scaleFactor <= 0) scaleFactor = 0.1;
              } else {
                  scaleFactor = size / sourceWidth;
                  strokeWidth = calculateStroke(weight, size);
              }
          }
          
          // Create temporary document
          var tempDoc = app.documents.add(DocumentColorSpace.RGB, size, size);
          
          // Unlock all layers in temp doc
          for (var li = 0; li < tempDoc.layers.length; li++) {
              tempDoc.layers[li].locked = false;
          }
          
          // Copy and paste the icon
          var tempGroup = sourceGroup.duplicate(tempDoc.layers[0], ElementPlacement.PLACEATEND);
          
          // Unlock the duplicated items
          unlockItems(tempGroup);
          
          // Scale it
          tempGroup.resize(
              scaleFactor * 100, scaleFactor * 100,
              true, true, true, true,
              scaleFactor * 100,
              Transformation.CENTER
          );
          
          // Center it
          var groupBounds = tempGroup.geometricBounds;
          var groupWidth = groupBounds[2] - groupBounds[0];
          var groupHeight = groupBounds[1] - groupBounds[3];
          
          var centerX = size / 2;
          var centerY = size / 2;
          
          var newLeft = centerX - (groupWidth / 2);
          var newTop = centerY + (groupHeight / 2);
          
          tempGroup.position = [newLeft, newTop];
          
          // Apply stroke width
          applyStrokeWidth(tempGroup, strokeWidth);
          
          // Scale inner elements for compound shapes if enabled
          if (options.shrinkInnerShapes && originalStrokeWidth > 0 && strokeWidth > 0) {
              var originalStrokeScaled = originalStrokeWidth * (size / sourceWidth);
              var strokeIncrease = strokeWidth - originalStrokeScaled;
              if (strokeIncrease > 0.001) {
                  var outerSize = getLargestElementSize(tempGroup);
                  var strokeIncreasePerSide = strokeIncrease / 2;
                  var innerScaleFactor;
                  // Multiply reduction ratio by 1.3 to shrink inner elements more aggressively
                  var shrinkMultiplier = 1.3;
                  if (outerSize > 0) {
                      var reductionRatio = (strokeIncreasePerSide / outerSize) * shrinkMultiplier;
                      innerScaleFactor = Math.max(0.5, 1 - reductionRatio);
                  } else {
                      var reductionRatio = (strokeIncrease / size) * shrinkMultiplier;
                      innerScaleFactor = Math.max(0.5, 1 - reductionRatio);
                  }
                  
                  scaleInnerElements(tempGroup, innerScaleFactor, true, outerSize);
                  var updatedBounds = tempGroup.geometricBounds;
                  var updatedWidth = updatedBounds[2] - updatedBounds[0];
                  var updatedHeight = updatedBounds[1] - updatedBounds[3];
                  var updatedLeft = centerX - (updatedWidth / 2);
                  var updatedTop = centerY + (updatedHeight / 2);
                  tempGroup.position = [updatedLeft, updatedTop];
              }
          }
          
          // Scale inner shapes based on inner stroke width increase (if advanced options are enabled)
          if (options.innerCalcMode !== undefined) {
              // Get original inner stroke width from source group
              var originalInnerStrokeWidth = getOriginalInnerStrokeWidth(sourceGroup);
              if (!originalInnerStrokeWidth || originalInnerStrokeWidth <= 0) {
                  // If no inner stroke found, use a default based on outer stroke
                  originalInnerStrokeWidth = originalStrokeWidth * 0.5;
              }
              
              // Scale original inner stroke to current size
              var originalInnerStrokeScaled = originalInnerStrokeWidth * (size / sourceWidth);
              
              // Calculate new inner stroke width based on advanced options
              var calculatedInnerStroke;
              if (options.innerCalcMode === 0) { // Auto
                  var divisor = options.innerAutoDivisor || 2;
                  var baseStrokeWidth = STROKE_WIDTHS[weight] || STROKE_WIDTHS[400];
                  calculatedInnerStroke = baseStrokeWidth / divisor;
              } else if (options.innerCalcMode === 1) { // Percent
                  var baseStroke = options.innerBaseStroke || 100;
                  var weightMultiplier = (weight - 100) / 100;
                  var increasePerWeight = options.innerIncreasePerWeight || 0;
                  calculatedInnerStroke = baseStroke + (baseStroke * (increasePerWeight / 100) * weightMultiplier);
              } else { // Amount
                  var baseStroke = options.innerBaseStroke || 100;
                  var weightMultiplier = (weight - 100) / 100;
                  var increasePerWeight = options.innerIncreasePerWeight || 0;
                  calculatedInnerStroke = baseStroke + (increasePerWeight * weightMultiplier);
              }
              
              // Scale to current size
              var newInnerStrokeWidth = (calculatedInnerStroke / 32) * size;
              
              // If new inner stroke is larger, scale down inner shapes
              var innerStrokeIncrease = newInnerStrokeWidth - originalInnerStrokeScaled;
              if (innerStrokeIncrease > 0.001) {
                  var outerSize = getLargestElementSize(tempGroup);
                  var innerStrokeIncreasePerSide = innerStrokeIncrease / 2;
                  var innerScaleFactorFromStroke;
                  var shrinkMultiplier = 1.3;
                  
                  if (outerSize > 0) {
                      var reductionRatio = (innerStrokeIncreasePerSide / outerSize) * shrinkMultiplier;
                      innerScaleFactorFromStroke = Math.max(0.5, 1 - reductionRatio);
                  } else {
                      var reductionRatio = (innerStrokeIncrease / size) * shrinkMultiplier;
                      innerScaleFactorFromStroke = Math.max(0.5, 1 - reductionRatio);
                  }
                  
                  // Apply additional scaling to inner shapes
                  scaleInnerElements(tempGroup, innerScaleFactorFromStroke, true, outerSize);
                  var updatedBounds = tempGroup.geometricBounds;
                  var updatedWidth = updatedBounds[2] - updatedBounds[0];
                  var updatedHeight = updatedBounds[1] - updatedBounds[3];
                  var updatedLeft = centerX - (updatedWidth / 2);
                  var updatedTop = centerY + (updatedHeight / 2);
                  tempGroup.position = [updatedLeft, updatedTop];
              }
          }
          
          // Apply inner shape styling (fill, stroke alignment, stroke width)
          if (options.innerShapeFill || options.innerStrokeAlign !== undefined || options.innerCalcMode !== undefined) {
              applyInnerShapeStyling(tempGroup, options, strokeWidth, weight, size);
          }
          
          // Reduce paths/groups inside inner shapes if enabled
          if (options.reduceInnerPaths) {
              reducePathsInsideInnerShapes(tempGroup, options, weight, size);
              // Recalculate bounds and reposition after path reduction
              var finalBounds = tempGroup.geometricBounds;
              var finalWidth = finalBounds[2] - finalBounds[0];
              var finalHeight = finalBounds[1] - finalBounds[3];
              var finalLeft = centerX - (finalWidth / 2);
              var finalTop = centerY + (finalHeight / 2);
              tempGroup.position = [finalLeft, finalTop];
          }
          
          // Generate filename based on pattern
          // Replace all occurrences of each placeholder
          var sizeStr = size + 'x' + size;
          var fileName = options.namingPattern;
          // Use regex with global flag to replace all occurrences
          fileName = fileName.replace(/\{name\}/g, options.name);
          fileName = fileName.replace(/\{weight\}/g, weight);
          fileName = fileName.replace(/\{size\}/g, sizeStr);
          
          // Build file path
          var filePath = exportFolder.fsName;
          
          // If organize by folders is enabled, create name/size folder structure
          if (options.organizeByFolders) {
              // Create folder structure: exportFolder/name/size/
              filePath += '/' + options.name;
              var nameFolder = new Folder(filePath);
              if (!nameFolder.exists) {
                  nameFolder.create();
              }
              
              filePath += '/' + (size + 'x' + size);
              var sizeFolder = new Folder(filePath);
              if (!sizeFolder.exists) {
                  sizeFolder.create();
              }
          } else {
              // Handle folder-based naming from pattern (create subdirectories if pattern contains /)
              var fileNameParts = fileName.split('/');
              if (fileNameParts.length > 1) {
                  for (var p = 0; p < fileNameParts.length - 1; p++) {
                      filePath += '/' + fileNameParts[p];
                      var subFolder = new Folder(filePath);
                      if (!subFolder.exists) {
                          subFolder.create();
                      }
                  }
                  fileName = fileNameParts[fileNameParts.length - 1];
              }
          }
          
          var svgFile = new File(filePath + '/' + fileName + '.svg');
          
          // SVG export options
          var svgOptions = new ExportOptionsSVG();
          svgOptions.embedRasterImages = options.embedRasterImages || false;
          
          // Map CSS properties location
          try {
              var cssIndex = options.cssProperties || 0;
              if (cssIndex === 0) {
                  svgOptions.cssProperties = SVGCSSPropertyLocation.PRESENTATIONATTRIBUTES;
              } else if (cssIndex === 1) {
                  svgOptions.cssProperties = SVGCSSPropertyLocation.STYLEELEMENTS;
              } else if (cssIndex === 2) {
                  svgOptions.cssProperties = SVGCSSPropertyLocation.ENTITIES;
              } else {
                  svgOptions.cssProperties = SVGCSSPropertyLocation.PRESENTATIONATTRIBUTES;
              }
          } catch (e) {
              svgOptions.cssProperties = SVGCSSPropertyLocation.PRESENTATIONATTRIBUTES;
          }
          
          // Map font subsetting (using numeric values for compatibility)
          try {
              var fontIndex = options.fontSubsetting || 0;
              if (fontIndex === 0) {
                  svgOptions.fontSubsetting = SVGFontSubsetting.None;
              } else if (fontIndex === 1) {
                  svgOptions.fontSubsetting = SVGFontSubsetting.GLYPHSUSED;
              } else if (fontIndex === 2) {
                  svgOptions.fontSubsetting = SVGFontSubsetting.COMMONENGLISH;
              } else if (fontIndex === 3) {
                  svgOptions.fontSubsetting = SVGFontSubsetting.ALLGLYPHS;
              } else {
                  svgOptions.fontSubsetting = SVGFontSubsetting.None;
              }
          } catch (e) {
              svgOptions.fontSubsetting = SVGFontSubsetting.None;
          }
          
          svgOptions.documentEncoding = SVGDocumentEncoding.UTF8;
          svgOptions.coordinatePrecision = options.coordinatePrecision || 2;
          
          try {
              tempDoc.exportFile(svgFile, ExportType.SVG, svgOptions);
              count++;
          } catch (e) {
              errors.push(fileName + ': ' + e.message);
          }
          
          // Close temp document without saving
          tempDoc.close(SaveOptions.DONOTSAVECHANGES);
      }
  }
  
  // Restore original items
  while (sourceGroup.pageItems.length > 0) {
      sourceGroup.pageItems[0].move(doc, ElementPlacement.PLACEATEND);
  }
  sourceGroup.remove();
  
  doc.selection = null;
  
  // Return results instead of showing alert (caller will show summary)
  return {
      count: count,
      errors: errors,
      exportFolder: exportFolder.fsName
  };
}

// Run the script
showDialog();

} // End of Illustrator check
